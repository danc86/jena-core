
DOCUMENT START
NON-TERMINALS
// --- Entry point
	parse	:=	( Statement )* <EOF>
	Statement	:=	( Directive | TriplesSameSubject ) <DOT>
	Directive	:=	<PREFIX> <QNAME_NS> Q_IRI_REF
// N3

// ---- TRIPLES
// <<<<< SPARQL extract
	TriplesSameSubject	:=	VarOrTerm PropertyListNotEmpty
		|	TriplesNode PropertyList
	PropertyList	:=	( PropertyListNotEmpty )?
// >>>>> SPARQL extract

// Non-recursive for Turtle long PropertyList tests
	PropertyListNotEmpty	:=	Verb ObjectList ( <SEMICOLON> ( Verb ObjectList )? )*
// Non-recursive for Turtle long PropertyList tests
	ObjectList	:=	Object ( <COMMA> Object )*
	Object	:=	GraphNode
// <<<<< SPARQL extract
	Verb	:=	( IRIref | <KW_A> | <ARROW> )
// -------- Triple expansions

// Anything that can stand in a node slot and which is
// a number of triples
	TriplesNode	:=	Collection
		|	BlankNodePropertyList
	BlankNodePropertyList	:=	<LBRACKET> PropertyListNotEmpty <RBRACKET>
// ------- RDF collections

// Code not as SPARQL/ARQ because of output ordering.
	Collection	:=	<LPAREN> ( GraphNode )+ <RPAREN>
// -------- Nodes in a graph pattern or template
	GraphNode	:=	VarOrTerm
		|	TriplesNode
	VarOrTerm	:=	( Var | GraphTerm | Formula )
	Formula	:=	<LBRACE> TriplesSameSubject ( <DOT> ( TriplesSameSubject )? )* <RBRACE>
// >>>>> SPARQL extract
	Var	:=	( <VAR1> | <VAR2> )
	GraphTerm	:=	IRIref
		|	RDFLiteral
		|	NumericLiteral
		|	BlankNode
		|	<NIL>
// ---- Basic terms
	NumericLiteral	:=	<INTEGER>
		|	<DECIMAL>
		|	<DOUBLE>
// >>>>> SPARQL extract
// Langtag oddity.
	RDFLiteral	:=	String ( Langtag | ( <DATATYPE> IRIref ) )?
	Langtag	:=	( <LANGTAG> | <PREFIX> )
// >>>>> SPARQL extract
// Node BooleanLiteral() : {}
// {
//   <TRUE> { return XSD_TRUE ; }
//  |
//   <FALSE> { return XSD_FALSE ; }
// }

// <<<<< SPARQL extract
	String	:=	( <STRING_LITERAL1> | <STRING_LITERAL2> | <STRING_LITERAL_LONG1> | <STRING_LITERAL_LONG2> )
	IRIref	:=	Q_IRI_REF
		|	QName
	QName	:=	( <QNAME> | <QNAME_NS> )
	BlankNode	:=	<BLANK_NODE_LABEL>
		|	<ANON>
	Q_IRI_REF	:=	<Q_IRIref>

DOCUMENT END
