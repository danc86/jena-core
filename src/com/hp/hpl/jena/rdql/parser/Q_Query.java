/*
 * (c) Copyright 2002, Hewlett-Packard Company, all rights reserved.
 * [See end of file]
 */

/* Generated By:JJTree: Do not edit this line. Q_Query.java */

package com.hp.hpl.jena.rdql.parser;

import com.hp.hpl.jena.rdql.* ;

import java.util.* ;

/** Concrete result of parsing a query.
 *  This is the top node inth eabstract syntax tree generated by the jjtree/javacc grammar.
 *  After being created this class builds a Query suitable for execution.  After that,
 *  this is not used, although many of the syntax tree nodes are used as they implement
 *  the interfaces needed by the abstarct query model.
 */

public class Q_Query extends SimpleNode
{
    public Q_Query(int id) { super(id); }

    public Q_Query(RDQLParser p, int id) { super(p, id); }

    private Query query = null ;

    // --------------------------------------------------------------------

    boolean selectAllVars = false ;

    // Post parsing fixups.
    // This is to rearrange the parse tree (pull up the structural nodes
    // and remove the need for later casting).
    // It separates the parse tree from the query processor.
    // By the end, the only classes of relevance should be:
    //      Var
    //      Expr
    //      Value
    //      TriplePattern
    // all nicely inserted into the Query object.

    // This code could live in the parser object itself but then it is stored in the
    // .jjt file, making development harder.

    public void phase2(Query q)
    {
        query = q ;
        try {
            int i = 0 ;
            int numQueryChildren = jjtGetNumChildren() ;

            // Select
            if ( jjtGetChild(i) instanceof Q_SelectClause )
            {
                extractVarList(q, jjtGetChild(i)) ;
                i++ ;
            }
            else
                throw new RDQL_InternalErrorException("Parser didn't catch absense of select clause") ;

            // Source
            if ( jjtGetChild(i) instanceof Q_SourceClause )
            {
                // SourceClause -> SourceSelector -> URL
                Node n = jjtGetChild(i).jjtGetChild(0).jjtGetChild(0) ;
                String source = ((Q_URL)n).urlString ;
                q.setSourceURL(source) ;
                i++ ;
            }

            // Triple patterns

            if ( jjtGetChild(i) instanceof Q_TriplePatternClause )
            {
                extractTriplePatterns(q, jjtGetChild(i)) ;
                i++ ;
            }
            else
                throw new RDQL_InternalErrorException("Parser didn't catch absense of triple patterns") ;

            // Constraints

            if ( i < numQueryChildren )
	            if ( jjtGetChild(i) instanceof Q_ConstraintClause )
	            {
	                extractConstraints(q, jjtGetChild(i)) ;
	                i++ ;
	            }

            // Prefixes
            // Do this always because of default prefixes.
            
            Q_PrefixesClause qpc = null ;
            if ( i < numQueryChildren && jjtGetChild(i) instanceof Q_PrefixesClause )
            {
            	qpc = (Q_PrefixesClause)jjtGetChild(i) ;
            	i++ ;
            }
            
            extractPrefixes(q, qpc) ;

            // Now allow any node (such as Q_URI) to do fixups
            this.fixup(this) ;
        }
        catch (ClassCastException e) { throw new RDQL_InternalErrorException("Parser generated illegal parse tree: "+e) ; }
        catch (RDQL_InternalErrorException e) { throw e ; }
        catch (Exception e) { throw new RDQL_InternalErrorException("Unknown exception: "+e) ; }
    }

    /** Formats the query from phase 2 in a style that is acceptable to the
     *  parser.  Note this is NOT guaranteed to be the same as the original string
     *  because we may have done optimizations or other rearranging.
     *  It should give the same answers on the same dataset.
     */

    public String toString()
    {
    	throw new UnsupportedOperationException ("Q_Query.toString()") ;
        /**
        StringBuff sbuff = new StringBuffer(1024) ;
        sbuff.append(RDQLParserConstants.tokenImage[RDQLParserConstants.SELECT]) ;
        for ( for i = 0 ; i < query.resultVars.size() ; i++ )
            sbuff.append(" ?").append(((Var)query.resultVars.get(i)).getVarName()) ;

        sbuff.append(" ").append(RDQLParserConstants.tokenImage[RDQLParserConstants.WHERE]) ;
        for ( for i = 0 ; i < query.constraints ; i++ )
        {
            TriplePattern tp = (TriplePattern)query.constraints.get(i) ;
            sbuff.append(tp.toString()) ;
        }
        **/
    }

    private void extractVarList(Query q, Node node)
    {
        int n = node.jjtGetNumChildren() ;
        selectAllVars = ( n == 0 ) ;

        for ( int i = 0 ; i < n ; i++ )
        {
            Node c = node.jjtGetChild(i) ;
            if ( ! (c instanceof Q_Var) )
                throw new RDQL_InternalErrorException("Internal error: parser created '"+c.getClass().getName()+"' when Q_Var expected") ;
            Q_Var v = (Q_Var)c ;
            q.addResultVar(v.varName) ;
        }
    }

    private void extractTriplePatterns(Query q, Node node)
    {
        Q_TriplePatternClause tpc = (Q_TriplePatternClause)node ;
        List patternVars = new ArrayList() ;
        int n = tpc.jjtGetNumChildren() ;
        for ( int j = 0 ; j < n ; j++ )
        {
            Q_TriplePattern tp = (Q_TriplePattern)tpc.jjtGetChild(j) ;
            if ( tp.jjtGetNumChildren() != 3 )
                throw new RDQL_InternalErrorException("Triple pattern has "+tp.jjtGetNumChildren()+" children") ;

            Slot rSlot = new Slot() ;
            Slot pSlot = new Slot() ;
            Slot oSlot = new Slot() ;

            // URI or Var
            doSlot(rSlot, patternVars, tp.jjtGetChild(0)) ;
            // URI or Var
            doSlot(pSlot, patternVars, tp.jjtGetChild(1)) ;
            // Value or Var
            doSlot(oSlot, patternVars, tp.jjtGetChild(2)) ;

            TriplePattern tmp = new TriplePattern(rSlot, pSlot, oSlot) ;
            q.addTriplePattern(tmp) ;
        }
        
        if ( selectAllVars )
        {
            for ( Iterator iter = patternVars.iterator() ; iter.hasNext() ; )
            {
                String varName = (String)iter.next() ;
                q.addResultVar(varName) ;
            }
        }
    }

    private void doSlot(Slot slot, List vars, Node node)
    {
        if ( node instanceof Var )
        {
            Var v = (Var)node ;
            if ( !vars.contains(v.getVarName()) )
                vars.add(v.getVarName()) ;
            slot.set((Var)node) ;
        }
        else
            slot.set((Value)node) ;
    }

    private void extractConstraints(Query q, Node node)
    {
        Q_ConstraintClause qcc = (Q_ConstraintClause)node ;
        int n = qcc.jjtGetNumChildren() ;
        for ( int j = 0 ; j < n ; j++ )
        {
            Expr expr = (Expr)qcc.jjtGetChild(j) ;
            q.addConstraint(new ConstraintExpr(expr)) ;
        }
    }

    private void extractPrefixes(Query q, Q_PrefixesClause qns)
    {
    	if ( qns == null )
    		return ;
    
        int n = qns.jjtGetNumChildren() ;
        for ( int j = 0 ; j < n ; j++ )
        {
            Q_PrefixDecl qnsd = (Q_PrefixDecl)qns.jjtGetChild(j) ;
            // They should appear in pairs: an identifier and a URI
            for ( int k = 0 ; k < qnsd.jjtGetNumChildren() ; k+=2 )
            {
                Q_Identifier id = (Q_Identifier)qnsd.jjtGetChild(k) ;
                Q_URI uri = (Q_URI)qnsd.jjtGetChild(k+1) ;
                query.setPrefix(id.toString(), uri.toString()) ;
            }
        }
    }
    
    String getPrefix(String prefix) { return query.getPrefix(prefix) ; }
}

/*
 *  (c) Copyright Hewlett-Packard Company 2001
 *  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes software developed by the
 * Apache Software Foundation (http://www.apache.org/).
 *
 */
