/* Generated By:JavaCC: Do not edit this line. RDFParser.java */
package com.hp.hpl.jena.rdf.arp;

import java.util.*;
import org.xml.sax.SAXException;

class RDFParser implements ARPErrorNumbers, RDFParserConstants {
    private static  URIReference RDFList = null;
    private static URIReference RDFfirst = null;
    private static URIReference RDFrest = null;
    private static URIReference RDFnil = null;



    static {
        try {
            RDFList     = new URIReference(ARPFilter.rdfns+"List");
            RDFnil        = new URIReference(ARPFilter.rdfns+"nil");

            RDFfirst = new URIReference(ARPFilter.rdfns+"first");
            RDFrest       = new URIReference(ARPFilter.rdfns+"rest");
        }
        catch (MalformedURIException e) {
            System.err.println("Internal error: " + e.toString());
            e.printStackTrace();
        }
    }


  static {
// Terminal description for error messages.
// The tokeniser (ARPFilter) defines what the tokens actually are.
     tokenImage[A_ABOUT] = "attribute rdf:about";
     tokenImage[A_ABOUTEACH] = "attribute rdf:aboutEach";
     tokenImage[A_BAGID] = "attribute rdf:bagID";
     tokenImage[A_ID] = "attribute rdf:ID";
     tokenImage[A_NODEID] = "attribute rdf:nodeID";
     tokenImage[A_OTHER] = "property attributes";
     tokenImage[A_PARSETYPE] = "rdf:parseType";
     tokenImage[A_RESOURCE] = "attribute rdf:resource";
     tokenImage[A_TYPE] = "attribute rdf:type";
     tokenImage[A_DATATYPE] = "attribute rdf:datatype";
     tokenImage[A_RDF_N] = "attribute rdf:rdf_NNN";
     tokenImage[A_XMLLANG] = "attribute xml:lang";
     tokenImage[A_XMLSPACE] = "attribute xml:space";
     tokenImage[A_XMLBASE] = "attribute xml:base";
     tokenImage[AV_RESOURCE] = "'Resource'";
     tokenImage[AV_LITERAL] = "'Literal'";
     tokenImage[AV_STRING] = "attribute value";
     tokenImage[CD_STRING] = "XML ELEMENT CONTENT";
     tokenImage[E_DESCRIPTION] = "start element rdf:Description";
     tokenImage[E_END] = "end element tag";
     tokenImage[E_LI] = "start element rdf:li";
     tokenImage[E_OTHER] = "general start element tag";
     tokenImage[E_RDF] = "start element rdf:RDF";
     tokenImage[E_RDF_N] = "start element rdf:rdf_NNN";
     tokenImage[AV_DAMLCOLLECTION] = "'daml:collection'";
     tokenImage[AV_COLLECTION] = "'Collection'";
     tokenImage[COMMENT]= "XML comment";
     tokenImage[PROCESSING_INSTRUCTION]="processing instruction";
     tokenImage[A_XMLNS]="namespace declaration";
     tokenImage[X_WARNING] = ""; // suppress messages about this ...
     tokenImage[X_SAX_EX] = ""; // suppress messages about this ...
   }

   ARPFilter arp;
   ParserSupport X;
   // For creating syntax error messages.
   Token startAttr;
   RDFParser(TokenPipe pipe, ARPFilter arp) {
     this(pipe);
     this.arp = arp;
     X = new ParserSupport(arp);
   }

/* FORMATTING CONVENTIONS
1: each element in production on own line at column 4 
2: kleene stars and optionals round single elements on same line
3: kleene stars and optionals round multiple elements using
   indentation levels of 2
4: code at column 40, possibly on same line as element
5: try/catch at column 30
6: | at column 2 on own line with comment // OR
*/
// Entry point where whole file is known to be rdf and
// so rdf:RDF element is optional.
// No kleene star - there can only be one document level element.
  final public void rdfFile(XMLContext ctxt) throws ParseException {
    whiteOrErr();
    rdfFileSub(ctxt);
    white1(false);
  }

  final public void rdfFileSub(XMLContext ctxt) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_RDF:
      rdf(ctxt);
      break;
    case E_DESCRIPTION:
    case E_OTHER:
    case E_LI:
    case E_RDF_N:
      obj(ctxt);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void white() throws ParseException {
    white1(true);
  }

  final public void white1(boolean warnOnPi) throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      oneWhite(warnOnPi);
    }
  }

  final public void whiteOrErr() throws ParseException {
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
        oneWhite(true);
        break;
      case X_WARNING:
        warning();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void oneWhite(boolean warnOnPi) throws ParseException {
                                         Token w;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CD_STRING:
      w = jj_consume_token(CD_STRING);
                                         X.checkWhite((StrToken)w);
      break;
    case PROCESSING_INSTRUCTION:
      pi(warnOnPi);
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    case X_SAX_EX:
      saxEx();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Token saxEx() throws ParseException {
                                         Token rslt;
    rslt = jj_consume_token(X_SAX_EX);
                                         X.saxException(rslt);
                                         {if (true) return rslt;}
    throw new Error("Missing return statement in function");
  }

  final public void empty() throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
      case PROCESSING_INSTRUCTION:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      oneEmpty();
    }
  }

  final public void oneEmpty() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PROCESSING_INSTRUCTION:
      pi(true);
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Token pi(boolean warnOnPi) throws ParseException {
                                         Token w;
    w = jj_consume_token(PROCESSING_INSTRUCTION);
                                         if (warnOnPi) X.processingInstruction(w);
                                         {if (true) return w;}
    throw new Error("Missing return statement in function");
  }

/* [6.1] RDF  ::= ['<rdf:RDF>'] obj* ['</rdf:RDF>'] */
  final public void rdf(XMLContext ctxt) throws ParseException {
    try {
      jj_consume_token(E_RDF);
      ctxt = xmlAttrs(ctxt);
      white();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case E_DESCRIPTION:
        case E_OTHER:
        case E_LI:
        case E_RDF_N:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        obj(ctxt);
        white();
      }
      jj_consume_token(E_END);
    } catch (ParseException e) {
                                       error_recovery(e);
    }
  }

/* [6.2] obj            ::= description | container */
  final public ARPResource obj(XMLContext ctxt) throws ParseException {
                                          ARPResource r =
                                                        new ARPResource(arp);
    description(ctxt,r);
                                         {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

/* [6.3] description    ::= '<rdf:Description' idAboutAttr? bagIdAttr? propAttr* '/>'
 *                        | '<rdf:Description' idAboutAttr? bagIdAttr? propAttr* '>'
 *                                       propertyElt* '</rdf:Description>'
 *                        | typedNode  */
  final public void description(XMLContext ctxt, ARPResource r) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case E_DESCRIPTION:
        jj_consume_token(E_DESCRIPTION);
        ctxt = xmlAttrs(ctxt);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case A_ID:
        case A_ABOUT:
        case A_NODEID:
          idAboutAttr(ctxt,r);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case A_BAGID:
          bagIdAttr(ctxt,r);
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case A_OTHER:
          case A_RDF_N:
          case A_TYPE:
            ;
            break;
          default:
            jj_la1[10] = jj_gen;
            break label_5;
          }
          propAttr(ctxt,r);
        }
        white();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case E_OTHER:
          case E_LI:
          case E_RDF_N:
            ;
            break;
          default:
            jj_la1[11] = jj_gen;
            break label_6;
          }
          propertyElt(ctxt,r);
          white();
        }
        jj_consume_token(E_END);
        break;
      case E_OTHER:
      case E_LI:
      case E_RDF_N:
        typedNode(ctxt,r);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
                                       error_recovery(e);
    }
  }

/*
 [6.5] idAboutAttr    ::= idAttr | aboutAttr | nodeIdAttr
*/
  final public void idAboutAttr(XMLContext ctxt,ARPResource r) throws ParseException {
                                         String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_ID:
      s = idAttr(ctxt);
                                         r.setAbout(s);
      break;
    case A_ABOUT:
      aboutAttr(ctxt,r);
      break;
    case A_NODEID:
      nodeIdAttr(ctxt,r);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 [6.6] idAttr         ::= ' ID="' IDsymbol '"'
*/
  final public String idAttr(XMLContext ctxt) throws ParseException {
                                         String s;
    jj_consume_token(A_ID);
    s = idSymbol(ctxt);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_7;
      }
      warning();
    }
                                         {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

/*
  [6.7] aboutAttr      ::= ' about="' URI-reference '"'
*/
  final public void aboutAttr(XMLContext ctxt,ARPResource r) throws ParseException {
                                         URIReference u;
    jj_consume_token(A_ABOUT);
    u = uriReference(ctxt);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_8;
      }
      warning();
    }
                                         r.setAbout(u);
  }

/*
   nodeIdAttr      ::= ' rdf:nodeID="' XMLNCName '"'
*/
  final public void nodeIdAttr(XMLContext ctxt,ARPResource r) throws ParseException {
                                         Token t;
    jj_consume_token(A_NODEID);
    t = jj_consume_token(AV_STRING);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_9;
      }
      warning();
    }
                                         r.setNodeId(X.checkNodeID(t));
  }

/*
  [6.9] bagIdAttr      ::= ' bagID="' IDsymbol '"'
*/
  final public void bagIdAttr(XMLContext ctxt,ARPResource r) throws ParseException {
                                        String s;
    jj_consume_token(A_BAGID);
    s = idSymbol(ctxt);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_10;
      }
      warning();
    }
                                         r.setBagId(s);
  }

/* 
 [6.10] propAttr       ::= typeAttr
                          | propName '="' string '"' (with embedded quotes escaped)
*/
  final public void propAttr(XMLContext ctxt,ARPResource r) throws ParseException {
                                         Token str;
                                         Token prop;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_TYPE:
      typeAttr(ctxt,r);
      break;
    case A_OTHER:
      // OR
         prop = jj_consume_token(A_OTHER);
      str = jj_consume_token(AV_STRING);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_11;
        }
        warning();
      }
                                           X.checkString(str);
                                           r.setPredicateObject(
                                                 ((ARPQname)prop)
                                                      .asURIReference(arp),
                                                 new ARPString((StrToken)str,
                                                            ctxt.getLang()) );
      break;
    case A_RDF_N:
      // OR
         prop = jj_consume_token(A_RDF_N);
      str = jj_consume_token(AV_STRING);
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_12;
        }
        warning();
      }
                                           X.checkString(str);
                                           r.setPredicateObject(
                                                 ((ARPQname)prop)
                                                      .asURIReference(arp),
                                                 new ARPString((StrToken)str,
                                                            ctxt.getLang()) );
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 [6.11] typeAttr       ::= ' type="' URI-reference '"'
*/
  final public void typeAttr(XMLContext ctxt,ARPResource r) throws ParseException {
                                         URIReference u;
    jj_consume_token(A_TYPE);
    u = uriReference(ctxt);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_13;
      }
      warning();
    }
                                         r.setType(u);
  }

/*
 [6.12] propertyElt    ::= '<' propName idAttr? '>' value '</' propName '>'
                         | '<' propName idAttr? parseLiteral '>'
                               literal '</' propName '>'
                         | '<' propName idAttr? parseResource '>'
                               propertyElt* '</' propName '>'
                         | '<' propName idRefAttr? bagIdAttr? propAttr* '/>'

Merged with:
 [6.29] referencedItem ::= '<rdf:li' resourceAttr '/>'
 [6.30] inlineItem     ::= '<rdf:li' '>' value </rdf:li>'
                         | '<rdf:li' parseLiteral '>' literal </rdf:li>'
                         | '<rdf:li' parseResource '>' propertyElt* </rdf:li>'

see working group notes.

In these productions E_END comes after the action in case the action 
throws a ParseException. In such a case, error_recovery is looking for the
E_END.
*/
  final public void propertyElt(XMLContext ctxt,ARPResource r) throws ParseException {
                                         Token p;
    try {
      p = propertyEltTag();
                                         p = (Token)p.clone();
                                         // We do not want to hold on
                                         // to the sequence of all subsequent
                                         // tokens.
                                         p.next = null;
      ctxt = xmlAttrs(ctxt);
      propertyEltIdAndValue(ctxt, r, p);
      jj_consume_token(E_END);
    } catch (ParseException e) {
                                         error_recovery(e);
    }
  }

  final public Token propertyEltTag() throws ParseException {
                                         Token p;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_OTHER:
      p = jj_consume_token(E_OTHER);
                                         {if (true) return p;}
      break;
    case E_LI:
      // OR
         p = jj_consume_token(E_LI);
                                         {if (true) return p;}
      break;
    case E_RDF_N:
      // OR
         p = jj_consume_token(E_RDF_N);
                                         {if (true) return p;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void propertyEltIdAndValue(XMLContext ctxt,ARPResource r, Token p) throws ParseException {
                                         String reify = null;
                                         Object v;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_ID:
      reify = idAttr(ctxt);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    v = propEltValue(ctxt);
                                         X.createTriple(r, p, v, reify );
  }

  final public Object propEltValue(XMLContext ctxt) throws ParseException {
                                         String xml;
                                         Object v;
                                         Token parseType;
                                         String parseTypeVal;
                                         ARPResource ptr;
                                         AResource daml;
                                         ARPString dtLex;
                                         URIReference dtURI;
                                         Location wh;
    if (jj_2_1(2)) {
      jj_consume_token(A_PARSETYPE);
      parseType = jj_consume_token(AV_LITERAL);
                                         parseTypeVal =
                                             ((StrToken)parseType).value;
                                         // Allow garbage collector
                                         // to operate for very large 
                                         // xml:literals
                                         wh = parseType.location;
                                         parseType = null;
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_14;
        }
        warning();
      }
      xml = litValue(ctxt.getNamespaces(),wh);
                                         {if (true) return
                                          new ARPString(xml,
                                                 ctxt.getLang(),
                                                 parseTypeVal );}
    } else if (jj_2_2(2)) {
      jj_consume_token(A_PARSETYPE);
      jj_consume_token(AV_DAMLCOLLECTION);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_15;
        }
        warning();
      }
      white();
      daml = damlCollection(ctxt);
                                          {if (true) return daml;}
    } else if (jj_2_3(2)) {
      jj_consume_token(A_PARSETYPE);
      jj_consume_token(AV_COLLECTION);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_16;
        }
        warning();
      }
      white();
      daml = collection(ctxt);
                                          {if (true) return daml;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_DATATYPE:
        // OR
           dtURI = datatypeAttr(ctxt);
        dtLex = string(ctxt);
                                          {if (true) return X.createDatatypeLiteral(dtURI,dtLex);}
        break;
      case A_PARSETYPE:
        jj_consume_token(A_PARSETYPE);
        jj_consume_token(AV_RESOURCE);
        label_17:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case X_WARNING:
            ;
            break;
          default:
            jj_la1[27] = jj_gen;
            break label_17;
          }
          warning();
        }
                                          ptr = new ARPResource(arp);
        white();
        label_18:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case E_OTHER:
          case E_LI:
          case E_RDF_N:
            ;
            break;
          default:
            jj_la1[28] = jj_gen;
            break label_18;
          }
          propertyElt(ctxt,ptr);
          white();
        }
                                          {if (true) return ptr;}
        break;
      case A_NODEID:
      case A_RESOURCE:
                                          ptr = new ARPResource(arp);
        resourceOrNodeIdAttr(ctxt,ptr);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case A_BAGID:
          bagIdAttr(ctxt,ptr);
          break;
        default:
          jj_la1[29] = jj_gen;
          ;
        }
        label_19:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case A_OTHER:
          case A_RDF_N:
          case A_TYPE:
            ;
            break;
          default:
            jj_la1[30] = jj_gen;
            break label_19;
          }
          propAttr(ctxt,ptr);
        }
        empty();
                                          {if (true) return ptr;}
        break;
      case A_OTHER:
      case A_RDF_N:
      case A_TYPE:
                                          ptr = new ARPResource(arp);
        label_20:
        while (true) {
          propAttr(ctxt,ptr);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case A_OTHER:
          case A_RDF_N:
          case A_TYPE:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_20;
          }
        }
        empty();
                                          {if (true) return ptr;}
        break;
      case A_BAGID:
                                          ptr = new ARPResource(arp);
        bagIdAttr(ctxt,ptr);
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case A_OTHER:
          case A_RDF_N:
          case A_TYPE:
            ;
            break;
          default:
            jj_la1[32] = jj_gen;
            break label_21;
          }
          propAttr(ctxt,ptr);
        }
        empty();
                                          {if (true) return ptr;}
        break;
      default:
        jj_la1[33] = jj_gen;
        // OR    This one last because it can expand to empty.
          v = value(ctxt);
                                          {if (true) return v;}
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public AResource damlCollection(XMLContext ctxt) throws ParseException {
                                         ARPResource cell, head;
                                         AResource tail;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_DESCRIPTION:
    case E_OTHER:
    case E_LI:
    case E_RDF_N:
                                         cell= new ARPResource(arp);
      head = obj(ctxt);
      white();
      tail = damlCollection(ctxt);
                                         cell.setPredicateObject( DAML.first,
                                                                  head,
                                                                  null );
                                         cell.setPredicateObject( DAML.rest,
                                                                  tail,
                                                                  null );
                                         cell.setType(DAML.List);
                                         {if (true) return cell;}
      break;
    default:
      jj_la1[34] = jj_gen;
                                        {if (true) return DAML.nil;}
    }
    throw new Error("Missing return statement in function");
  }

  final public AResource collection(XMLContext ctxt) throws ParseException {
                                         ARPResource cell, head;
                                         AResource tail;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_DESCRIPTION:
    case E_OTHER:
    case E_LI:
    case E_RDF_N:
                                         cell= new ARPResource(arp);
      head = obj(ctxt);
      white();
      tail = collection(ctxt);
                                        cell.setPredicateObject( RDFfirst,
                                                                  head,
                                                                  null );
                                         cell.setPredicateObject( RDFrest,
                                                                  tail,
                                                                  null );
                                         cell.setType(RDFList);
                                         {if (true) return cell;}
      break;
    default:
      jj_la1[35] = jj_gen;
                                        {if (true) return RDFnil;}
    }
    throw new Error("Missing return statement in function");
  }

/*
 [6.13] typedNode      ::= '<' typeName idAboutAttr? bagIdAttr? propAttr* '/>'
                         | '<' typeName idAboutAttr? bagIdAttr? propAttr* '>'
                               propertyElt* '</' typeName '>'
 We do the action at the right point to reflect the XML
 document order in the bagID bag (if any).
*/
  final public void typedNode(XMLContext ctxt, ARPResource r) throws ParseException {
                                         Token type;
    type = typedNodeTag();
                                         type = (Token)type.clone();
                                         type.next = null;
    ctxt = xmlAttrs(ctxt);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_ID:
    case A_ABOUT:
    case A_NODEID:
      idAboutAttr(ctxt,r);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_BAGID:
      bagIdAttr(ctxt,r);
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
                                         r.setType(
                                               ((ARPQname)type)
                                                   .asURIReference(arp));
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_OTHER:
      case A_RDF_N:
      case A_TYPE:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_22;
      }
      propAttr(ctxt,r);
    }
    white();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case E_OTHER:
      case E_LI:
      case E_RDF_N:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_23;
      }
      propertyElt(ctxt,r);
      white();
    }
    jj_consume_token(E_END);
  }

  final public Token typedNodeTag() throws ParseException {
                                         Token rslt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_OTHER:
      rslt = jj_consume_token(E_OTHER);
                                         {if (true) return rslt;}
      break;
    case E_RDF_N:
      // OR
         rslt = jj_consume_token(E_RDF_N);
                                         arp.parseWarning(
                                           WARN_RDF_NN_AS_TYPE,
                                           rslt.location,
                                           ((ARPQname)rslt).qName +
                                           " is being used as a type."
                                         );
                                         {if (true) return rslt;}
      break;
    case E_LI:
      // OR
         rslt = jj_consume_token(E_LI);
                                         arp.parseWarning(
                                           ERR_LI_AS_TYPE,
                                           rslt.location,
                                           ((ARPQname)rslt).qName +
                                           " is being used as a type."
                                         );
                                         {if (true) return rslt;}
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 [6.17] value          ::= obj | string
 
 RETURN the value, note the class of the return type
 distinguishes which expansion was used.
 Here lies the major issue with the grammar.
 As we look at white space at the beginning of value then
 we don't know if it is a string value, or just filling up to
 the next obj. We use a special javaCC lookahead here.
 What is says is to use the string rule in the case that we
 have any amount of parsed character data (including none) 
 followed by an end element.
 The end element is matched in the calling production! (yuk!)
*/
  final public Object value(XMLContext ctxt) throws ParseException {
                                         Object rslt;
    if (jj_2_4(2147483647)) {
      rslt = string(ctxt);
                                         {if (true) return rslt;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
      case E_DESCRIPTION:
      case E_OTHER:
      case E_LI:
      case E_RDF_N:
        white();
        rslt = obj(ctxt);
        white();
                                         {if (true) return rslt;}
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 [6.18] resourceAttr   ::= ' resource="' URI-reference '"'
*/
  final public void resourceAttr(XMLContext ctxt, ARPResource r) throws ParseException {
                                         URIReference u;
    jj_consume_token(A_RESOURCE);
    u = uriReference(ctxt);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_24;
      }
      warning();
    }
                                         r.setAbout(u);
  }

/*
 [6.18a] datatypeAttr   ::= ' datatype="' URI-reference '"'
*/
  final public URIReference datatypeAttr(XMLContext ctxt) throws ParseException {
                                         URIReference u;
    jj_consume_token(A_DATATYPE);
    u = uriReference(ctxt);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_25;
      }
      warning();
    }
                                         {if (true) return u;}
    throw new Error("Missing return statement in function");
  }

  final public void resourceOrNodeIdAttr(XMLContext ctxt, ARPResource r) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_RESOURCE:
      resourceAttr(ctxt,r);
      break;
    case A_NODEID:
      nodeIdAttr(ctxt,r);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/*
 [6.20] URI-reference  ::= string, interpreted per [URI]
 
 RETURN the URI-reference.
*/
  final public URIReference uriReference(XMLContext ctxt) throws ParseException {
                                         Token t;
    t = jj_consume_token(AV_STRING);
                                         {if (true) return X.makeURIReference(ctxt,t);}
    throw new Error("Missing return statement in function");
  }

/*
 [6.21] IDsymbol       ::= (any legal XML name symbol)
 
 RETURN the IDsymbol
*/
  final public String idSymbol(XMLContext ctxt) throws ParseException {
                                         Token t;
    t = jj_consume_token(AV_STRING);
                                         StrToken strtok = (StrToken)t;
                                         String rslt = ctxt.getBase()+"#"+ strtok.value;
                                         X.checkIdSymbol(ctxt,strtok,rslt);
                                         {if (true) return  rslt;}
    throw new Error("Missing return statement in function");
  }

/*
 [6.24] string         ::= (any XML text, with "<", ">", and "&" escaped)
 
 RETURN the string.

Notice the action within the kleene star.
*/
  final public ARPString string(XMLContext ctxt) throws ParseException {
                                         Vector pieces = new Vector();
                                         Token tok = null;
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_26;
      }
      tok = string1(pieces);
    }
                                         ARPString rslt =
                                                new ARPString(pieces,ctxt.getLang());
                                         X.checkNormalFormC(tok,rslt);
                                         {if (true) return rslt;}
    throw new Error("Missing return statement in function");
  }

  final public Token string1(Vector rslts) throws ParseException {
                                         Token rslt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CD_STRING:
      rslt = jj_consume_token(CD_STRING);
                                         X.checkComposingChar(rslt);
                                         rslts.add(rslt);
                                         {if (true) return rslt;}
      break;
    case COMMENT:
      rslt = jj_consume_token(COMMENT);
                                         {if (true) return rslt;}
      break;
    case PROCESSING_INSTRUCTION:
      rslt = pi(true);
                                         {if (true) return rslt;}
      break;
    case X_SAX_EX:
      // OR
        rslt = saxEx();
                                         {if (true) return rslt;}
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
  @return The new XML context.
  @param ctxt The current XML context.
*/
  final public XMLContext xmlAttrs(XMLContext ctxt) throws ParseException {
                                         startAttr = getToken(1);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_XMLNS:
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_27;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        warning();
        break;
      case A_XMLNS:
        ctxt = xmlns(ctxt);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_XMLBASE:
      ctxt = xmlBase(ctxt);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[49] = jj_gen;
          break label_28;
        }
        warning();
      }
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_XMLLANG:
      ctxt = xmlLang(ctxt);
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[51] = jj_gen;
          break label_29;
        }
        warning();
      }
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_XMLSPACE:
      jj_consume_token(A_XMLSPACE);
      jj_consume_token(AV_STRING);
      label_30:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[53] = jj_gen;
          break label_30;
        }
        warning();
      }
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
                                         {if (true) return ctxt;}
    throw new Error("Missing return statement in function");
  }

  final public XMLContext xmlns(XMLContext ctxt) throws ParseException {
                                         Token prefix, uri;
    prefix = jj_consume_token(A_XMLNS);
    uri = jj_consume_token(AV_STRING);
                                          X.checkNamespaceURI(uri);
                                          {if (true) return ctxt.addNamespace(prefix,uri);}
    throw new Error("Missing return statement in function");
  }

  final public XMLContext xmlBase(XMLContext ctxt) throws ParseException {
                                         Token t;
    jj_consume_token(A_XMLBASE);
    t = jj_consume_token(AV_STRING);
                                         {if (true) return X.changeXMLBase(ctxt, t);}
    throw new Error("Missing return statement in function");
  }

  final public XMLContext xmlLang(XMLContext ctxt) throws ParseException {
                                         Token t;
    jj_consume_token(A_XMLLANG);
    t = jj_consume_token(AV_STRING);
                                         StrToken rslt = (StrToken)t;
                                         X.checkXMLLang(rslt);
                                         {if (true) return ctxt.withLang(rslt.value);}
    throw new Error("Missing return statement in function");
  }

// issue a warning,
// will throw ParseException if this warning is
// being treated as an error.
  final public void warning() throws ParseException {
                                         Token t;
    t = jj_consume_token(X_WARNING);
                                         arp.parseWarning((Warn)t);
  }

// XML RULES

// Entry point for a file containing RDF somewhere
// indicated by the rdf:RDF element.
  final public void embeddedFile(XMLContext ctxt) throws ParseException {
    whiteOrErr();
    root(ctxt);
    white1(false);
  }

  final public void root(XMLContext ctxt) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_RDF:
      rdf(ctxt);
      break;
    case E_DESCRIPTION:
    case E_OTHER:
    case E_LI:
    case E_RDF_N:
      element(ctxt);
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// For parsing before we find an rdf:RDF element.
  final public void element(XMLContext ctxt) throws ParseException {
    startElement();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_31;
      }
      nowarning();
    }
    ctxt = xmlAttrsNoWarnings(ctxt);
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_ID:
      case A_ABOUT:
      case A_NODEID:
      case A_BAGID:
      case A_OTHER:
      case A_RDF_N:
      case A_TYPE:
      case A_PARSETYPE:
      case A_RESOURCE:
      case A_DATATYPE:
      case A_ABOUTEACH:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_32;
      }
      attr();
    }
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
      case E_RDF:
      case E_DESCRIPTION:
      case E_OTHER:
      case E_LI:
      case E_RDF_N:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_33;
      }
      content(ctxt);
    }
    jj_consume_token(E_END);
  }

  final public void attr() throws ParseException {
    attrName();
    attrValue();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_34;
      }
      nowarning();
    }
  }

// Eat a warning.
  final public void nowarning() throws ParseException {
    jj_consume_token(X_WARNING);
  }

  final public XMLContext xmlAttrsNoWarnings(XMLContext ctxt) throws ParseException {
                                         startAttr = getToken(1);
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_XMLNS:
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_35;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        warning();
        break;
      case A_XMLNS:
        ctxt = xmlns(ctxt);
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_XMLBASE:
      ctxt = xmlBase(ctxt);
      label_36:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[62] = jj_gen;
          break label_36;
        }
        nowarning();
      }
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_XMLLANG:
      ctxt = xmlLang(ctxt);
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case X_WARNING:
          ;
          break;
        default:
          jj_la1[64] = jj_gen;
          break label_37;
        }
        nowarning();
      }
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
                                         {if (true) return ctxt;}
    throw new Error("Missing return statement in function");
  }

  final public void content(XMLContext ctxt) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_RDF:
      rdf(ctxt);
      break;
    case CD_STRING:
      jj_consume_token(CD_STRING);
      break;
    case E_DESCRIPTION:
    case E_OTHER:
    case E_LI:
    case E_RDF_N:
      element(ctxt);
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      break;
    case PROCESSING_INSTRUCTION:
      jj_consume_token(PROCESSING_INSTRUCTION);
      break;
    case X_SAX_EX:
      saxEx();
      break;
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void startElement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_DESCRIPTION:
      jj_consume_token(E_DESCRIPTION);
      break;
    case E_LI:
      jj_consume_token(E_LI);
      break;
    case E_OTHER:
      jj_consume_token(E_OTHER);
      break;
    case E_RDF_N:
      jj_consume_token(E_RDF_N);
      break;
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// XML for rdf:parseType="Literal".
  final public Token litStartElement() throws ParseException {
                                          Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case E_DESCRIPTION:
      // One of:
          t = jj_consume_token(E_DESCRIPTION);
                                         {if (true) return t;}
      break;
    case E_LI:
      t = jj_consume_token(E_LI);
                                         {if (true) return t;}
      break;
    case E_OTHER:
      t = jj_consume_token(E_OTHER);
                                         {if (true) return t;}
      break;
    case E_RDF_N:
      t = jj_consume_token(E_RDF_N);
                                         {if (true) return t;}
      break;
    case E_RDF:
      t = jj_consume_token(E_RDF);
                                         {if (true) return t;}
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Token litAttrName() throws ParseException {
                                         Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_ABOUT:
      // One of: 
          t = jj_consume_token(A_ABOUT);
                                         {if (true) return t;}
      break;
    case A_ABOUTEACH:
      t = jj_consume_token(A_ABOUTEACH);
                                         {if (true) return t;}
      break;
    case A_BAGID:
      t = jj_consume_token(A_BAGID);
                                         {if (true) return t;}
      break;
    case A_ID:
      t = jj_consume_token(A_ID);
                                         {if (true) return t;}
      break;
    case A_OTHER:
      t = jj_consume_token(A_OTHER);
                                         {if (true) return t;}
      break;
    case A_PARSETYPE:
      t = jj_consume_token(A_PARSETYPE);
                                         {if (true) return t;}
      break;
    case A_DATATYPE:
      t = jj_consume_token(A_DATATYPE);
                                         {if (true) return t;}
      break;
    case A_NODEID:
      t = jj_consume_token(A_NODEID);
                                         {if (true) return t;}
      break;
    case A_RDF_N:
      t = jj_consume_token(A_RDF_N);
                                         {if (true) return t;}
      break;
    case A_RESOURCE:
      t = jj_consume_token(A_RESOURCE);
                                         {if (true) return t;}
      break;
    case A_TYPE:
      t = jj_consume_token(A_TYPE);
                                         {if (true) return t;}
      break;
    case A_XMLBASE:
      t = jj_consume_token(A_XMLBASE);
                                         {if (true) return t;}
      break;
    case A_XMLLANG:
      t = jj_consume_token(A_XMLLANG);
                                         {if (true) return t;}
      break;
    case A_XMLSPACE:
      t = jj_consume_token(A_XMLSPACE);
                                         {if (true) return t;}
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void attrName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case A_ABOUT:
      jj_consume_token(A_ABOUT);
      break;
    case A_ABOUTEACH:
      jj_consume_token(A_ABOUTEACH);
      break;
    case A_BAGID:
      jj_consume_token(A_BAGID);
      break;
    case A_ID:
      jj_consume_token(A_ID);
      break;
    case A_OTHER:
      jj_consume_token(A_OTHER);
      break;
    case A_PARSETYPE:
      jj_consume_token(A_PARSETYPE);
      break;
    case A_RDF_N:
      jj_consume_token(A_RDF_N);
      break;
    case A_RESOURCE:
      jj_consume_token(A_RESOURCE);
      break;
    case A_TYPE:
      jj_consume_token(A_TYPE);
      break;
    case A_NODEID:
      jj_consume_token(A_NODEID);
      break;
    case A_DATATYPE:
      jj_consume_token(A_DATATYPE);
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Token attrValue() throws ParseException {
                                        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AV_STRING:
      // One of:  
          t = jj_consume_token(AV_STRING);
                                         {if (true) return t;}
      break;
    case AV_LITERAL:
      t = jj_consume_token(AV_LITERAL);
                                         {if (true) return t;}
      break;
    case AV_DAMLCOLLECTION:
      t = jj_consume_token(AV_DAMLCOLLECTION);
                                         {if (true) return t;}
      break;
    case AV_RESOURCE:
      t = jj_consume_token(AV_RESOURCE);
                                         {if (true) return t;}
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
  @param allNs The namespace prefixes currently in-scope
  @param ns The namespace prefixes as currently visible
*/
  final public void litElement(StringBuffer val,Map allNs, Map ns) throws ParseException {
                                         Token t;
                                         SortedMap visiblyUsed = new TreeMap();
                                         SortedMap attrs = new TreeMap();
    t = litStartElement();
                                         X.startLitElement(val,
                                                                t,
                                                                visiblyUsed);
                                         t = (Token)t.clone();
                                         t.next = null;
                                         startAttr = getToken(1);
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[72] = jj_gen;
        break label_38;
      }
      nowarning();
    }
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_XMLNS:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_39;
      }
      allNs = litXmlns(allNs, visiblyUsed);
    }
    label_40:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case A_ID:
      case A_ABOUT:
      case A_NODEID:
      case A_BAGID:
      case A_OTHER:
      case A_RDF_N:
      case A_TYPE:
      case A_PARSETYPE:
      case A_RESOURCE:
      case A_DATATYPE:
      case A_XMLSPACE:
      case A_XMLBASE:
      case A_XMLLANG:
      case A_ABOUTEACH:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_40;
      }
      litAttr(attrs,visiblyUsed);
    }
                                          ns=X.litAttributes(val,attrs,visiblyUsed,ns,allNs,t);
                                          val.append('>');
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
      case E_RDF:
      case E_DESCRIPTION:
      case E_OTHER:
      case E_LI:
      case E_RDF_N:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_41;
      }
      litContent(val,allNs,ns);
    }
    jj_consume_token(E_END);
                                         X.endLitElement(val,t);
  }

  final public Map litXmlns(Map ns, Map used) throws ParseException {
                                         Token prefix, uri;
    prefix = jj_consume_token(A_XMLNS);
    uri = jj_consume_token(AV_STRING);
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_42;
      }
      nowarning();
    }
                                         {if (true) return X.litNamespace(prefix,uri,ns,used);}
    throw new Error("Missing return statement in function");
  }

  final public void litAttr(Map attrs,Map visiblyUsed) throws ParseException {
                                         Token attr; Token val; String key;
    attr = litAttrName();
                                         key=X.litAttrName( attr,
                                                visiblyUsed);
    val = attrValue();
                                         attrs.put(key,X.litAttribute(attr,val));
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case X_WARNING:
        ;
        break;
      default:
        jj_la1[77] = jj_gen;
        break label_43;
      }
      nowarning();
    }
  }

/**
  @param allNs The namespace prefixes currently in-scope
  @param ns The namespace prefixes as currently visible
*/
  final public void litContent(StringBuffer val,Map allNs, Map ns) throws ParseException {
                                         Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CD_STRING:
      t = jj_consume_token(CD_STRING);
                                         X.litText(val,t);
      break;
    case COMMENT:
      // OR
         t = jj_consume_token(COMMENT);
                                         X.litComment(val,t);
      break;
    case PROCESSING_INSTRUCTION:
      // OR
         t = jj_consume_token(PROCESSING_INSTRUCTION);
                                         X.litProcessingInstruction(val,t);
      break;
    case E_RDF:
    case E_DESCRIPTION:
    case E_OTHER:
    case E_LI:
    case E_RDF_N:
      litElement(val,allNs,ns);
      break;
    case X_SAX_EX:
      saxEx();
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String litValue(Map allNs, Location wh) throws ParseException {
                                           StringBuffer buf = new StringBuffer();
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD_STRING:
      case COMMENT:
      case X_SAX_EX:
      case PROCESSING_INSTRUCTION:
      case E_RDF:
      case E_DESCRIPTION:
      case E_OTHER:
      case E_LI:
      case E_RDF_N:
        ;
        break;
      default:
        jj_la1[79] = jj_gen;
        break label_44;
      }
      litContent(buf,allNs,ParserSupport.xmlNameSpace());
    }
                                         String r = buf.toString();
                                         X.checkEncoding(r,wh);
                                         {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

  void error_recovery(ParseException e) throws ParseException, ParseException {
  e.setStartAttribute( startAttr );
  try {
    arp.userError(e);
  }
  catch (SAXException sax) {
    if ( sax == e ) {
        e.setFatal(true);
        throw e;
    }
    throw new WrappedException(sax);
  }
  if ( e.getFatal() )
     throw e;

  Token t;
  int needed = 1;
  do {
    t = getNextToken();
    switch ( t.kind ) {
     case EOF:
       ParseException failure = new ParseException(ERR_UNABLE_TO_RECOVER,"Error recovery failed.");
       failure.setFatal(true);
       throw failure;
     case E_END: needed--; break;
     case E_LI:
     case E_RDF:
     case E_RDF_N:
     case E_DESCRIPTION:
     case E_OTHER: needed++; break;
    }
  } while (needed>0);
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(COMMENT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(A_PARSETYPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(AV_COLLECTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(A_PARSETYPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(AV_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(X_SAX_EX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(PROCESSING_INSTRUCTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(A_PARSETYPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(AV_DAMLCOLLECTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(CD_STRING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_45()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(E_END)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public TokenManager token_source;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[80];
  final private int[] jj_la1_0 = {0x700a0,0x1e,0x4000001e,0x4000001e,0x1e,0x14,0x14,0x70080,0x700,0x1000,0xe000,0x70000,0x70080,0x700,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0xe000,0x40000000,0x70000,0x100,0x40000000,0x40000000,0x40000000,0x40000000,0x70000,0x1000,0xe000,0xe000,0xe000,0x308f400,0x70080,0x70080,0x700,0x1000,0xe000,0x70000,0x70000,0x7009e,0x40000000,0x40000000,0x1000400,0x1e,0x1e,0x48000000,0x48000000,0x40000000,0x10000000,0x40000000,0x20000000,0x40000000,0x4000000,0x700a0,0x40000000,0x8308f700,0x700be,0x40000000,0x48000000,0x48000000,0x40000000,0x10000000,0x40000000,0x20000000,0x700be,0x70080,0x700a0,0xb708f700,0x8308f700,0xb00800,0x40000000,0x8000000,0xb708f700,0x700be,0x40000000,0x40000000,0x700be,0x700be,};
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;


  public RDFParser(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[32];
    for (int i = 0; i < 32; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 80; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 32; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
