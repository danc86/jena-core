<html>
<head>
<title>ModelSpec 2.2 howto</title>
<style>
pre {
    background-color: #eee;
    margin-top: 2mm;
    margin-bottom: 2mm;
    margin-left: 5mm;
	margin-right: 5mm
    }
<link href="../styles/doc.css" rel="stylesheet" type="text/css">
</style>
</head>
<body>
<h1>ModelSpec howto - describing Jena 2.2 models in RDF</h1>

<i>draft for discussion 13th August 2004</i>
<br><i>version 0.2</i>

<h1>introduction</h1>

This document describes the ModelSpec features for Jena 2.2 (although
they will be available in CVS before Jena 2.2 is released). They build
on the experimental features available in Jena 2.0 and 2.1, but have
been extended to increase flexibility and uniformity.

<p>The intention is to be able to specify how a model is constructed 
using a configuration file, input stream, URL, or other way of getting 
RDF into a Jena process, and for this configuration to be capabile of
specifying anything that the ModelFactory class can construct.

<p>A more formal document is available: the 
<a href="modelspec-details-2-2.html">ModelSpec design document</a>. 
Here we concentrate on how to use ModelSpecs in general.

<p>The ModelSpec descriptions use the Jena Model Specification
vocabulary, which is available in the vocabulary class <code>JMS</code>
and which will be referred to using the prefix <code>jms</code>.
Jena defines this vocabulary namespace as 

<blockquote>
http://jena.hpl.hp.com/2003/08/jms#
</blockquote>

<h1>creating a ModelSpec</h1>

<code>ModelSpec</code>s are created by calling one of the ModelFactory 
methods named <code>createSpec</code>, which create a ModelSpec from
an RDF description. There are four variants of <code>createSpec</code>:

<ul>
<li>createSpec( Resource r , Model m ). This is the core method.
    The ModelSpec is created from the sub-graph of <code>m</code>
	rooted at <code>r</code>. The resource <code>r</code> identifies
	the model specification. Model specifications are described in
	detail in [A LATER SECTION].

<li>createSpec( Model m ). The ModelSpec is created from the sub-graph
    of <code>m</code> rooted at the unique resource with type
	<code>jms:ModelSpec</code>.

<li>createSpec( Resource r ). This abbreviates 
    <code>createSpec( r, r.getModel() )</code>.

</ul>

All ModelSpecs are interpreted using RDFS inference with respect to the
JMS schema found at <b>reference</b> and also in the JMS vocabulary
class <b>full name</b>.

<h1>using a ModelSpec</h1>

A ModelSpec doesn't describe a single model, but a way of making
many models of the same kind. Often these models are named, or built
on named models. The two important creation methods are:

<ul>
<li><code>createModel()</code>: create a new model according to
    the specification. This method is used by 
	<code>ModelFactory.createModel(ModelSpec)</code>. You may need
	to cast this model to the appropriate type - in particular,
	if you're expecting an <code>OntModel</code>.
	
	<p>[Should we provide createOntModel and createInfModel as
	wrappers for these cases?]

<li><code>createModelOver(String name)</code>: most <code>ModelSpec</code>s
    have an underlying <a href="../javadoc/com/hp/hpl/jena/rdf/model/ModelMaker.html">
    <code>ModelMaker</code></a>. This method creates a new Model where
    any underlying Model has the given <code>name</code> in that ModelMaker.
    For particularly simple <code>ModelSpec</code>s, the result is that
    Model. The usual case of interest is when the ModelSpec creates
	models in a database.
</ul>

Once a ModelSpec has been constructed, the RDF on which it is based
may become inacessible; indeed, it is possible to construct some
ModelSpecs without using RDF at all. To regenerate RDF "equivalent"
to that description, use:

<ul>

<li><code>getDescription()</code>: returns an RDF description which
    describes this ModelSpec. If the original RDF description had no
    superfluous statements, this model is likely "the same" as that
    original, ie isomorphic. This is a useful way to save an RDF
    description to be used in a later <code>createSpec</code>.

</ul>

<h1>Some simple ModelSpec descriptions</h1>

We will write our descriptions in N3, rather than RDF/XML, for clarity.
We will assume the usual Jena prefixes (rdfs, jms, rdf), call the
root resource of the description "_:this", and make heavy use of
bnodes. Your own descriptions can use whatever mixtures of bnodes
and URIs you like.
 
<h2>PlainModelSpec, no frills</h2>

A ModelSpec for plain [non-reasoning], default models can be as 
simple as

<pre>
_:this rdf:type jms:DefaultModelSpec .
</pre>

This will construct a default model (ie the same kind of
Model that <code>ModelFactory.createDefaultModel()</code>
will construct). If anything more complicated that this is
required, then a <i>model maker</i> must be specified. 

<pre>
_:this jms:maker _:maker .
</pre>

It happens that this specificiation, where a model maker is
identified but not further described, also produces a ModelSpec
that makes default models. Pick whichever you find most pleasing.

<p>If you wish to create models with different <i>reification styles</i>,
then the maker can specify the style explicitly.

<pre>
_:this jms:maker _:maker .
_:maker jms:reificationStyle jms:rsMinimal .
</pre>

This will produce models which have the <i>minimal</i> reification
style. (For an explanation of the different styles, see <b>THAT DOCUMENT</b>.
[This fragment may disappear if we can eliminate reification styles
completely.])

<h2>PlainModelSpec, file-based</h2>

You can specify a model that is loaded from, and written back
to, some file using a FileModelMaker. The model is loaded from
the file when it is created, and written back when it is
closed. The <code>fileBase</code>, the directory in which the
file is found, has to be specified.

<pre>
_:this jms:maker _:maker .
_:maker jms:fileBase "/tmp" .
</pre>

Filing-system names are of course implementation-specific,
so if you expect to move <code>fileBase</code>-using ModelSpecs
between systems, take care.

<p>A file-based ModelSpec can use <code>createModelOver(String s)</code>
to create models loaded from the file whose name is <code>s</code>
within the <code>fileBase</code>. If the file does not exist, the
model will initially be empty, but will be written back when closed.

<p>Of course, a refication style can be specified as well as a
filebase. There is no need for a file-based model to be opened
with the same style each time it is used - the reification style 
is not preserved.

<hr>
Unmodified original from here .....

<h2>PlainModelSpec from a database</h2>

Database model makers need to have their connection specified. Each
such <code>ModelSpec</code> will create its own connection. 

<pre>
    _this jms:maker _A
    _A jms:reificationMode jms:rsStandard
    _A jms:dbURL "jdbc:mysql://some.database.machine.eg/jenaDB"
    _A jms:dbUser "william.blake"
    _A jms:dbPassword "tyger, tyger"
    _A jms:dbType "MySQL"
</pre>

<h2>an inference model</h2>

Inference models require a reasoner specification as well as a
base ModelMaker. In the current ModelSpec implementation, the
reasoner only requires the URI describing the necessary inference:
other reasoner properties will be introduced in later revisions.

<pre>
    _this jms:maker _M
    _this jms:reasonsWith _R
    _M jms:reificationMode jms:rsMinimal
    _R jms:reasoner http://jena.hpl.hp.com/2003/RDFSExptRuleReasoner
</pre>

<h2>an ontology model</h2>

Finally, here's the description of an ontology model for OWL Lite over
a database model, while doing RDFS inference.

<pre>
    _this jms:importMaker _D
    _this jms:ontLanguage "http://www.w3.org/TR/owl-features/#term_OWLLite"
    _this jms:docManager _DM
    _this jms:reasonsWith _R
    
    _D jms:dbURL "jdbc:mysql://some.database.machine.eg/jenaDB"
    _D jms:dbUser "william.blake"
    _D jms:dbPassword "tyger, tyger"
    _D jms:dbType "MySQL"    

    _R jms:reasoner http://jena.hpl.hp.com/2003/RDFSExptRuleReasoner
</pre>

The <code>docManager</code> bnode has no attached properties; in this
case, the resulting <code>OntModelSpec</code> will use the default
document manager. Adding the triple

<pre>
    _DM jms:policyPath "file:/somehere/policy"
</pre>

will use a document manager which takes its policy from the specified
file; see the <a href="../javadoc/com/hp/hpl/jena/ontology/OntDocumentManager.html">
OntDSocumentManager</a> documentation for more details.
<h1>GUBBINS TO BE ASSIMILATED</h1>

, passing it the Model containing the
RDF description. The description uses the <a href="../javadoc/com/hp/hpl/jena/vocabulary/JMS.html">JMS (Jena Model Specification)
vocabulary</a>. The result is a ModelSpec object specialised to the
description. <code>createSpec</code> finds the unique resource in
<code>desc</code> with <code>RDF.type</code> <code>JMS.ModelSpec</code>,
and then find the "most specific" subtype of <code>JMS.ModelSpec</code>
that resource has. [Fortunately, the current type tree allows this.]

<p>That type identifies the kind of Java ModelSpec to create. The
constructor for that type analyses the description to find the
relevant properties: irrelevant ones are ignored. [The mapping from
RDF types to ModelSpecCreators is driven from the
<a href="../javadoc/com/hp/hpl/jena/rdf/model/ModelSpecCreatorRegistry.html">
ModelSpecCreatorRegistry
</a>
and is extensible.]

<p>The <code>createSpec(Resource,Model)</code> method performs the same function,
but the ModelSpec resource (which must have type <code>JMS.ModelSpec</code>)
is passed as the first argument, rather than being the unique ModelSpec
resource in the description.

<p>In both cases, the <code>Model</code> can be replaced by a [non-bnode]
<code>Resource</code> whose URI names the model to be loaded.
</body>
</html>
