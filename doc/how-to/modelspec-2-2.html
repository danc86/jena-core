<html>
<head>
<title>ModelSpec 2.2 howto</title>
<link href="../styles/doc.css" rel="stylesheet" type="text/css">
<style>
p.note {
    background-color: #eef;
    }
pre {
    background-color: #eee;
    margin-top: 2mm;
    margin-bottom: 2mm;
    margin-left: 5mm;
	margin-right: 5mm
    }
</style>
</head>
<body>
<h1>ModelSpec howto - describing Jena 2.2 models in RDF</h1>

<h1>introduction</h1>

This document describes the ModelSpec features for Jena 2.2. They build
on the experimental features available in Jena 2.0 and 2.1, but have
been extended to increase flexibility and uniformity.

<p>The intention is to be able to specify how a model is constructed 
using a configuration file, input stream, URL, or other way of getting 
RDF into a Jena process, and for this configuration to be capable of
specifying anything that the ModelFactory class can construct.

<p>A more formal document will be available: the 
<a href="modelspec-details-2-2.html">ModelSpec design document</a>. 
Here we concentrate on how to use ModelSpecs in general.

<p>The ModelSpec descriptions use the Jena Model Specification
vocabulary, which is available in the vocabulary class 
<code>JenaModelSpec</code>
and which will be referred to using the prefix <code>jms</code>.
Jena defines this vocabulary namespace as 

<blockquote>
http://jena.hpl.hp.com/2003/08/jms#
</blockquote>

<h1>differences from the original ModelSpecs</h1>

The revised ModelSpec differs from the original in several minor ways
and a few major ones, those being:

<ul>
<li>the additional of specifications for rulesets and schemas.

<li>the separation out of database connection specifications.

<li>the special type <code>Shared</code> to allow values to be
    shared by specifications. [Shared is not implemented.]

</ul>


<h1>creating a ModelSpec</h1>

<code>ModelSpec</code>s are created by calling one of the ModelFactory 
methods named <code>createSpec</code>, which create a ModelSpec from
an RDF description. There are three variants of <code>createSpec</code>:

<ul>
<li>createSpec( Resource r , Model m ). This is the core method.
    The ModelSpec is created from the sub-graph of <code>m</code>
	rooted at <code>r</code>. The resource <code>r</code> identifies
	the model specification. 

<li>createSpec( Model m ). The ModelSpec is created from the sub-graph
    of <code>m</code> rooted at the unique resource with type
	<code>jms:ModelSpec</code>.

<li>createSpec( Resource r ). This abbreviates 
    <code>createSpec( r, r.getModel() )</code>.

</ul>

All ModelSpecs are interpreted using partial RDFS inference with 
respect to the JMS schema found at 
<b>vocabularies/jena-mode-spec.n3</b> 
and also in the vocabulary
class <b>com.hp.hpl.jena.vocabulary.JenaModelSpec</b>.

<p>By "partial" inference, we mean that the vocabulary is RDFS-complete,
and that the specification has types inferred from 
<code>RDFS.domain</code> and <code>RDF.type</code>statements.
This abbreviated inference avoids some reasoner overheads. 

<h1>using a ModelSpec</h1>

A ModelSpec doesn't describe only a single model, but a way of making
many models of the same kind. Often these models are named, or built
on named models. The important creation method is:

<ul>
<li><code>createModel()</code>: create a new model according to
    the specification. This method is used by 
	<code>ModelFactory.createModel(ModelSpec)</code>. You may need
	to cast this model to the appropriate type - in particular,
	if you're expecting an <code>OntModel</code>.
</ul>

Once a ModelSpec has been constructed, the RDF on which it is based
may become inacessible; indeed, it is possible to construct some
ModelSpecs without using RDF at all. To regenerate RDF "equivalent"
to that description, use:

<ul>

<li><code>getDescription()</code>: returns an RDF description which
    describes this ModelSpec. If the original RDF description had no
    superfluous statements, this model is likely "the same" as that
    original, ie isomorphic. This is a useful way to save an RDF
    description to be used in a later <code>createSpec</code>.

</ul>

<h1>Some simple ModelSpec descriptions</h1>

We will write our descriptions in N3, rather than RDF/XML, for clarity.
We will assume the usual Jena prefixes (rdfs, jms, rdf), call the
root resource of the description "_:this", and make heavy use of
bnodes. Your own descriptions can use whatever mixtures of bnodes
and URIs you like.
 
<h2>PlainModelSpec, no frills</h2>

A ModelSpec for plain [non-reasoning], default models can be as 
simple as

<pre>
_:this rdf:type jms:DefaultModelSpec .
</pre>

This will construct a default model (ie the same kind of
Model that <code>ModelFactory.createDefaultModel()</code>
will construct). If anything more complicated that this is
required, then a <i>model maker</i> must be specified. 

<pre>
_:this jms:maker _:maker .
</pre>

It happens that this specificiation, where a model maker is
identified but not further described, also produces a ModelSpec
that makes default models. Pick whichever you find most pleasing.

<p>If you wish to create models with different <i>reification styles</i>,
then the maker can specify the style explicitly.

<pre>
_:this jms:maker _:maker .
_:maker jms:reificationStyle jms:rsMinimal .
</pre>

This will produce models which have the <i>minimal</i> reification
style. (For an explanation of the different styles, see <b>THAT DOCUMENT</b>.

<h2>PlainModelSpec, file-based</h2>

You can specify a model that is loaded from, and written back
to, some file using a FileModelMaker. The model is loaded from
the file when it is created, and written back when it is
closed. The <code>fileBase</code>, the directory in which the
file is found, has to be specified.

<pre>
_:this jms:maker _:maker .
_:maker jms:fileBase "/tmp" .
</pre>

Filing-system names are of course implementation-specific,
so if you expect to move <code>fileBase</code>-using ModelSpecs
between systems, take care.

<p>A file-based ModelSpec can use <code>createModelOver(String s)</code>
to create models loaded from the file whose name is <code>s</code>
within the <code>fileBase</code>. If the file does not exist, the
model will initially be empty, but will be written back when closed.

<p>Of course, a refication style can be specified as well as a
filebase. There is no need for a file-based model to be opened
with the same style each time it is used - the reification style 
is not preserved.

<h2>PlainModelSpec from a database</h2>

A Plain (ie non-inferring, non-ontologogical) model can be a
persistent database model. Jena supports JDBC-connected database models;
these are specified using an RDB model-maker. Each such model created
will use it's own database connection.

<pre>
_:this jms:maker _:maker .
_:maker jms:reificationMode jms:rsStandard .
_:maker jms:hasConnection _:conn .

_:conn jms:dbURL jdbc:mysql://some.database.machine.eg/jenaDB .
_:conn jms:dbUser "william.blake" .
_:conn jms:dbPassword "tyger, tyger" .
_:conn jms:dbType "MySQL" .
</pre>

The model-maker is specified as being a Jena RDB model-maker by
the <code>hasConnection</code>. Several models may share the same
(or similar) connections.

<p>
The connection URL specifies the database to connect to; the same 
database can support many different Jena models. (Note that this
is a URI, not a literal.) The user and password 
are required to (weakly) authenticate the connection. The type is
required so that the correct database drivers can be loaded. Note
the (in-)security implications of the database password being stored
in plain text in the ModelSpec description document - these are
partly bypassed by using the <code>shared</code> property discussed
later.

<h2>an inference model</h2>

An inference model is characterised by having a reasoner specification
as well as a (base) model-maker specification. The reasoner engine is
specified by its URI (as known to the Jena ReasonerRegistry), and
additional properties, such as schemas and rules.

<pre>
_:this jms:maker _:maker .
_:this jms:reasonsWith _:reasoner .
_:reasoner jms:reasoner &lt;http://jena.hpl.hp.com/2003/RDFSExptRuleReasoner&gt; .
</pre>

<p class=note>[check that the URI remains correct]

<p>This is the simplest reasoner specification - just giving the URL of
the reasoner. Any other properties of the reasoner take on its usual
defaults. 

<p>Reasoners may be supplied with a schema or schemas as the "initial 
base" for their reasoning - for example, an RDFS reasoner may be
given an RDFS schema and do sub-type reasoning in advance of being
applied to a particular model. Schemas can be specified by giving their
URLs.

<pre>
_:reasoner jms:schemaURL &lt;http://some.domain.xyz/RDFS/cunning&gt; .
</pre>

If several schemas are supplied, they are merged into a single schema
to feed to the reasoner. 

<p>Similarly, a schema can be specified using a ModelSpec.
[Discussed later, when we've sorted out the unresolved issue of
 model specs that identify <i>particular</i> models.]

<pre>
_:reasoner jms:schema _:modelSpec .
</pre>

If the reasoner is a rule-based reasoner, it may be loaded with
additional rules. Those rules may be specified in the ModelSpec
description, or be identified by URL.

<pre>
_:reasoner jms:ruleSetURL &lt;http://some.domain.xyz/RULES/straight&gt; .
</pre>

The URL identifies a resource containing the rules, written in
an appropriate notation. Several <code>ruleSetURL</code>s may be
given; all the rules are loaded into the reasoner in no particular
order.


<p>Similarly, 

<pre>
_:reasoner jms:ruleSet _:set .
</pre>

specifies a set of rules located elsewhere in this specification,
as properties of <code>_:set</code>. Multiple such <code>ruleSet</code>s
can be given, and they my be freely mixed with <code>ruleSetURL</code>s.

<h3>ruleSet specifications</h3>

The ruleset specifications allow different reasoner specifications to
share rule specifications (and possibly the rules themselves). The
simplest such specification is the empty one:

<pre>
_:set rdf:type jms:RuleSet .
</pre>

which may be useful as a placeholder (or a leftover from pruning
away rulesets). Additional rules may be specified inline or by
URL:

<pre>
_:set jms:hasRule "some proper rule text here" .
_:set jms:ruleSetURL &lt;http://some.domain/RULES/example&gt; .
</pre>

Both <code>hasRule</code> and <code>ruleSetURL</code> may be
present as often as required. Since both predicates have
domain <code>RuleSet</code>, the type declaration may be
omitted.

<h2>ontology models</h2>

An OntModel specification has additional properties for specifying
the ontology language and document-manager details. For example,
using the same database connection description as our earlier example,

<pre>
_:this jms:importMaker _:conn .
_:this jms:ontLanguage "http://www.w3.org/TR/owl-features/#term_OWLLite" .
_:this jms:docManager _:DM .
_:this jms:reasonsWith _:R .

_:R jms:reasoner http://jena.hpl.hp.com/2003/RDFSExptRuleReasoner .
</pre>

specifies OntModels for the OWL Lite language, using the RDFS rule-based
reasoner. The OntModels will take their base models from the database.
The document manager has been given no specific properties, so the
default document manager will be used.

<h1>shared specifications</h1>

[Not implemented in this release.]

<p>By default, each time a model is constructed using a ModelSpec, new
instances of all the subcomponents of that description are created.
This is not always a wise choice, especially if those subcomponents
consume lots of space or take a long time to prepare - eg, a large
schema for a reasoner.

<p>Any sub-specification can be made <i>shared</i> by giving it the
<code>Shared</code> type:

<pre>
_:conn rdf:type jms:Shared .
</pre>

When a component of type <code>Shared</code> is requested, if there
is already a <code>Shared</code> component created from equivalent RDF,
then that component is returned rather than a new component being
created. 

<p>The method <code>ModelFactory.share( Resource r, Object o )</code>
declares that the resource <code>r</code>, which must have RDF type
<code>Shared</code>, has shared value <code>o</code>. Any modelspec
component whose description matches <code>r</code> will resolve to
the value <code>o</code>.

<p>By "equivalent RDF" we mean that the submodels reachable from 
<code>r</code> are isomorphic.

<p>So, for the database connection example, the resource 
<code>_:conn</code> can be declared shared in the user's application,
without the user's database name and password appearing in the ModelSpec.

</body>
</html>
