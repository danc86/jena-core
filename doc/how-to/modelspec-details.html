<html>
<head>
<title>Model Specification API</title>
<link href="../styles/doc.css" rel="stylesheet" type="text/css">
<style>
pre {
    background-color: #eee;
    margin-top: 2mm;
    margin-bottom: 2mm;
    margin-left: 0;
    }
</style>
</head>
<body>

<b>authors</b>: Chris Dollin, Dave Reynolds
<br><b>date</b>: August 27th, 2003
<br><b>version</b>: 1.0

<h1>Model Specification API</h1>

This document describes the version of the Jena Model Specification API for
Jena 2.0. The JMS is neither complete nor frozen; we hope users will
experiment with the early implementations and offer sugegstions that we
can incorporate into later versions.

<p>This document is a revision of a design note circulated to the jena-devel
mailing list earlier this month.

<h2>Requirements</h2>

The purpose of the model specification API is to allow Model configurations
  to be declaratively specified, for example, so that an application can create
  or access a model defined by some configuration parameter or file.

<p>More specifically we wish to:

<ul>
<li>enable declarative and serializable specification of model structure

<li>common cases should be easy, for example by providing prebuilt specifications

<li>it should be possible to create, open or wrap models according to a spec

<li>the machinery should be extensible to new, community defined, model types
    in the future

</ul>

<h2>Scope</h2>

We can imagine models as comprising three layers - an API, a storage layer
  and an optional intervening inference layer. The range of options and configuration
  parameters needed for these layers by Jena2, as it currently stands, is captured
  below.

<table border="1" cellspacing="0" cellpadding="0">
  <tr>
    <td>
      <div align="center"><b>Layer</b></div>
    </td>
    <td>
      <div align="center"><b>Option</b></div>
    </td>
    <td>
      <div align="center"><b>Parameter</b></div>
    </td>
  </tr>
  <tr>
    <td rowspan="3"><b>API</b></td>
    <td >Model</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>InfModel</td>
    <td>[reasoner]</td>
  </tr>
  <tr>
    <td>OntModel</td>
    <td>OntModelSpec = importMaker, docManager, [reasoner], language</td>
  </tr>
  <tr>
    <td><b>Inference</b></td>
    <td>&nbsp;</td>
    <td>reasoner = reasonerURI + config</td>
  </tr>
  <tr>
    <td rowspan="3"><b>Storage</b></td>
    <td>Mem</td>
    <td>reificationMode</td>
  </tr>
  <tr>
    <td>File</td>
    <td>reificationMode, baseDir</td>
  </tr>
  <tr>
    <td>DB</td>
    <td>reificationMode, IDBConnection = url, user, password, type</td>
  </tr>
</table>

<p>Future Jena extensions may add additional options to any of these layers.

<p>The bulk of these cases are easy to specify declaratively.

<p>There are two cases where the additional option of passing an existing specific
  runtime java object as a parameter would be desirable - a java.sql.Connection
  for a dB store and a OntDocumentManager for an OntModel specification. The bulk
  of Model usage could be covered without this additional capability.

<h2>API Design</h2>

<p>The basic design approach to define a new Java object, <code>ModelSpec</code>,
to hold the parsed specification for a type of <code>Model</code>. Instances
of <code>ModelSpec</code> can be passed to new <code>ModelFactory</code>
calls to create models according to the specification. An instance of <code>ModelSpec</code>
can be created from an RDF specification, either one loaded from file using
the normal Jena functions or an inline one in some shorthand syntax like N3.

<p>For extensibility <code>ModelSpec</code> is an interface.
Future types of <code>Model</code>s can be associated with new implementation
of <code>ModelSpec</code>. The already-existing <code>OntModelSpec</code>
performed a very similar job, and was revised to implement <code>ModelSpec</code>
and used as a driver in the code development.

<pre>
<b>interface</b> ModelSpec
    Model createModel()
    Model createModelOver( String name )
    Model getDescription()
    [other description-producing/augmenting methods]
</pre>

A ModelSpec can be used to create a Model, to create a Model "over" a base Model
found in an internal ModelMaker, and to produce an RDF description of the same
kind as was used to create it.

<p>It is convenient to refactor so that the existing <code>ModelMaker</code>
interface extends <code>ModelSpec</code>: thus a ModelMaker can be used
wherever a ModelSpec is required.

<pre>    
<b>class</b> PlainModelSpec <b>implements</b> ModelSpec
    PlainModelSpec( Model description )
    ModelMaker: maker
    getter/setters as required

<b>class</b> InfModelSpec <b>implements</b> ModelSpec <b>extends</b> PlainModelSpec
    InfModelSpec( Model description )
    Reasoner: reasoner
    getter/setters for <code>reasoner</code>

<b>class</b> OntModelSpec <b>implements</b> ModelSpec <b>extends</b> InfModelSpec
    OntModelSpec( Model description )
    [other OntModelSpec constructors as before]
    String: language
    OntDocumentManager: docManager
    ModelMaker: importMaker
    getter/setters as current
</pre>

[Earlier versions of this design used <code>init</code> methods, but the current
implementation does not, leaving all initialisation to the constructor and further
tweaking to the class-specific getters and setters. This choice can be revisted
if necessary.]

<p>The design also allows multiple Specs to be described by a single Model, and to
have a ModelSpec factory:

<pre>
<b>class</b> ModelSpecFactory
   ModelSpec create()
   ModelSpec create(Resource config)
   Map createMultipleSpec(Model model)
   ModelSpec createFromN3(String config)

<b>class</b> ModelFactory
   ...
   Model createModel(ModelSpec)
   Model convertTo(ModelSpec, Model)
   ...
   ModelSpec DEFAULT
   ModelSpec MEM_RDFS_INF
   ModelSpec ONT_OWL_MEM_RULE_INF
   etc
</pre>

The existing implementation does not provide this functionality.

<p>The already-existing <code>ModelFactory</code> methods remain
as convenience methods but the single <code>createModel</code> call now covers
most of the existing uses, except for the final casting of the returned 
<code>Model</code> to the appropriate static type.

<h2>Extensions and design notes</h2>

<p>We imagine a single RDF configuration file being used for defining multiple
models. The <code>createMultipleSpec</code> is an early hook to simplify this
sort of usage but additional convenience functions can be imagined. In particular,
it might be handy to be able to refer to the separate specifications by name
rather than by URI given the lack of legibility of URIs.</p>

<p>As defined above if one needs to have a specification build on an existing
runtime object like a dB <code>Connection</code> or a replacement <code>ontDocumentManager</code>
that would have to be done programmatically (e.g. by a <code>setMaker</code>
call on the <code>ModelSpec</code>). To cope with this, the <code>ModelSpecImpl</code>
class provides a way to create a new <code>Resource</code> object associated with
a Java value, and to retrieve that object from the resource. This allows descriptions
to indirectly refer to computed values. [Serialising such models loses the value.]
  
<h2>RDF Schema</h2>

<p>A suggested RDFS representation of specifications is outlined below.
We have used an informal syntax in which:

<pre><code>
<b>class</b> foo <i>subClassOf</i> bar
    prop: Range
</code></pre>

<p>means:</p>

<pre><code>
    jms:foo rdf:type rdfs:Class .
    jms:foo rdfs:subClassOf bar .
    jms:prop rdf:type rdfs:Property .
    jms:prop rdfs:range jms:Range .
</code></pre>

<code>jms</code> is the namespace prefix used for the specifcations; Jena binds
it to <b>http://jena.hpl.hp.com/2003/08/jms#</b>.

<pre>  
<b>class</b> ModelSpec
    maker : MakerSpec

<b>class</b> InfModelSpec <i>subClassOf</i> ModelSpec
    reasonsWith : ReasonerSpec

<b>class</b> OntModelSpec <i>subClassOf</i> InfModelSpec
    ontLanguage : String
    importMaker : MakerSpec
    docManger : DocManager

<b>class</b> DocManager 
    policyPath : String
    
<b>class</b> MakerSpec
    reificationMode : String

<b>class</b> MemMaker <i>subClassOf</i> MakerSpec

<b>class</b> FileMaker <i>subClassOf</i> MakerSpec
    filebase : String

<b>class</b> DBMaker <i>subClassOf</i> MakerSpec
    dbURL : Resource
    dbUser : String
    dbPassword : String
    dbType : String
    dbClass: String
    dbConnection : [magic Java object reference]

<b>class</b> ReasonerSpec
    reasoner : Resource
    .. other reasoner specific config props defined by reasoner ..
</pre>

</body>
</html>
