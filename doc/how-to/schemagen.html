<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>HOWTO for Jena 2 schemagen</title>
  <link rev="made" href="mailto:ian.dickinson@hp.com" />
  <meta name="generator" content="NoteTab Pro 4.92" />
  <meta name="author" content="Ian Dickinson" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <link href="../styles/doc.css" rel="stylesheet" type="text/css" />
  <style type="text/css">
  <!--
  .syntax { text-align: left; font: 100% "Courier new", monospace; background: #eee;  }
  .syntaxPrompt { text-align: left; background: #eee; }
  -->
  </style>
</head>

<body>

<h1>Jena schemagen HOWTO</h1>

<p>The <code>schemagen</code> provided with Jena is used to convert an OWL, DAML or RDFS vocabulary into a Java class file that contains
static constants for the terms in the vocabulary. This documents outlines the use of schemagen, and the various options and templates
that may be used to control the output.
</p>
<p>
Schemagen is typeically invoked from the command line or from a built script (such as Ant).
Synopsis of the command:</p>
<pre>
java jena.schemagen -i &lt;input&gt; [-a &lt;namespaceURI&gt;] [-o &lt;output file&gt;] [-c &lt;config uri&gt;] [-s &lt;syntax&gt;] ...
</pre>
<p>Schemagen is highly configurable, either with command line options or by RDF information read from a configuration file.
<b>Many</b> other options are defined, and these are described in detail below.  Note that the <code>CLASSPATH</code> environment variable must
be set to include the Jena <code>.jar</code> libraries.
</p>
<h2>Summary of configuration options</h2>
<p>For quick reference, here is a list of all of the schemagen options (both command line and configuration file). The use of these options is explained in detail below.</p>
<table width="800" border="1" cellspacing="0" cellpadding="1">
<caption align="bottom">Table 1: schemagen options</caption>
  <tr align="left"><th width="190">Command line option</th><th width="180">RDF config file property</th><th width="430">Meaning</th></tr>
  <tr> <td>-a &lt;uri&gt;</td> <td>sgen:namespace</td> <td>The namespace URI for the vocabulary. Names with this URI as prefix are automatically included in the generated vocabulary.</td> </tr>
  <tr> <td>-c &lt;filename&gt;<br>-c &lt;url&gt;</td> <td>&nbsp;</td> <td>Specify an alternative config file.</td> </tr>
  <tr> <td>--classdec &lt;string&gt;</td> <td>sgen:classdec</td> <td>Additional decoration for class header (such as <code>implements</code>)</td> </tr>
  <tr> <td>--classnamesuffix &lt;string&gt;</td> <td>sgen:classnamesuffix</td> <td>Option for adding a suffix to the generated class name, e.g. "Vocab".</td> </tr>
  <tr> <td>--classSection &lt;string&gt;</td> <td>sgen:classSection</td> <td>Section declaration comment for class section.</td> </tr>
  <tr> <td>--classTemplate &lt;string&gt;</td> <td>sgen:classTemplate</td> <td>Template for writing out declarations of class resources.</td> </tr>
  <tr> <td>--daml</td> <td>sgen:daml</td> <td>Specify that the language of the source ontology is DAML+OIL.</td> </tr>
  <tr> <td>--declarations &lt;string&gt;</td> <td>sgen:declarations</td> <td>Additional declarations to add at the top of the class.</td> </tr>
  <tr> <td>-e &lt;string&gt;</td> <td>sgen:encoding</td> <td>The surface syntax of the input file (e.g. RDF/XML, N3). Defaults to RDF/XML.</td> </tr>
  <tr> <td>--footer &lt;string&gt;</td> <td>sgen:footer</td> <td>Template for standard text to add to the end of the file.</td> </tr>
  <tr> <td>--header &lt;string&gt;</td> <td>sgen:header</td> <td>Template for the file header, including the class comment.</td> </tr>
  <tr> <td>-i &lt;filename&gt;<br>-i &lt;url&gt;</td> <td>sgen:input</td> <td>Specify the input document to load</td> </tr>
  <tr> <td>--include &lt;uri&gt;</td> <td>sgen:include</td> <td>Option for including non-local URI's in vocabulary</td> </tr>
  <tr> <td>--individualsSection &lt;string&gt;</td> <td>sgen:individualsSection</td> <td>Section declaration comment for individuals section.</td> </tr>
  <tr> <td>--individualTemplate &lt;string&gt;</td> <td>sgen:individualTemplate</td> <td>Template for writing out declarations of individuals.</td> </tr>
  <tr> <td>--marker &lt;string&gt;</td> <td>sgen:marker</td> <td>Specify the marker string for substitutions, default is '%'</td> </tr>
  <tr> <td>-n &lt;string&gt;</td> <td>sgen:classname</td> <td>The name of the generated class. The default is to synthesise a name based on input document name.</td> </tr>
  <tr> <td>--noclasses</td> <td>sgen:noclasses</td> <td>Option to suppress classes in the generated vocabulary file</td> </tr>
  <tr> <td>--nocomments</td> <td>sgen:noComments</td> <td>Turn off all comment output in the generated vocabulary</td> </tr>
  <tr> <td>--noheader</td> <td>sgen:noHeader</td> <td>Prevent the output of a file header, with class comment etc.</td> </tr>
  <tr> <td>--noindividuals</td> <td>sgen:noindividuals</td> <td>Option to suppress individuals in the generated vocabulary file.</td> </tr>
  <tr> <td>--noproperties</td> <td>sgen:noproperties</td> <td>Option to suppress properties in the generated vocabulary file.</td> </tr>
  <tr> <td>-o &lt;filename&gt;<br />-o &lt;dir&gt;</td> <td>sgen:output</td> <td>Specify the destination for the output. If the given value evaluates to a directory, the generated class will be placed in that directory with a file name formed from the generated (or given) class name with ".java" appended.</td> </tr>
  <tr> <td>--ontology</td> <td>sgen:ontology</td> <td>The generated vocabulary will use the ontology API terms, in preference to RDF model API terms.</td> </tr>
  <tr> <td>--owl</td> <td>sgen:owl</td> <td>Specify that the language of the source is OWL (the default). Note that RDFS is a subset of OWL, so this setting also suffices for RDFS.</td> </tr>
  <tr> <td>--package &lt;string&gt;</td> <td>sgen:package</td> <td>Specify the Java package name.</td> </tr>
  <tr> <td>--propSection &lt;string&gt;</td> <td>sgen:propSection</td> <td>Section declaration comment for properties section.</td> </tr>
  <tr> <td>--propTemplate &lt;string&gt;</td> <td>sgen:propTemplate</td> <td>Template for writing out declarations of property resources.</td> </tr>
  <tr> <td>-r &lt;uri&gt;</td> <td>&nbsp;</td> <td>Specify the uri of the root node in the RDF configuration model.</td> </tr>
  <tr> <td>--uppercase</td> <td>sgen:uppercase</td> <td>Option for mapping constant names to uppercase (like Java constants). Default is to leave the case of names unchanged.</td> </tr>
</table>

<h2>What does schemagen do?</h2>
<p>
RDFS, OWL and DAML+OIL provide a very convenient means to define a controlled vocabulary or ontology. For general ontology processing, Jena provides various API's to allow the source files to be read in and manipulated. However, when developing an application, it is frequently convenient to refer to the controlled vocabulary terms directly from Java code.  This leads typically to the declaration of constants, such as:
<code><pre>
    public static final Resource A_CLASS = new ResourceImpl( "http://example.org/schemas#a-class" );
</pre></code>
When these constants are defined manually, it is tedious and error-prone to maintain them in synch with the source ontology file. Schemagen automates the production of Java constants that correspond to terms in an ontology document. By automating the step from source vocabulary to Java constants, a source of error and inconsistency is removed.
</p>
<h3>Example</h3>
<p>
Perhaps the easiest way to explain the detail of what schemagen does is to show an example. Consider the following mini-RDF vocabulary:
</p>
<code><pre>
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns="http://example.org/eg#"
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xml:base="http://example.org/eg"&gt;
 &nbsp;&lt;rdfs:Class rdf:ID="Dog"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;A class of canine companions&lt;/rdfs:comment&gt;
 &nbsp;&lt;/rdfs:Class&gt;
 &nbsp;&lt;rdf:Property rdf:ID="petName"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;The name that everyone calls a dog&lt;/rdfs:comment&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:domain rdf:resource="http://example.org/eg#Dog" /&gt;
 &nbsp;&lt;/rdf:Property&gt;
 &nbsp;&lt;rdf:Property rdf:ID="kennelName"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;Posh dogs have a formal name on their KC certificate&lt;/rdfs:comment&gt;
 &nbsp;&lt;/rdf:Property&gt;
 &nbsp;&lt;Dog rdf:ID="deputy"&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdfs:comment&gt;Deputy is a particular Dog&lt;/rdfs:comment&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;kennelName&gt;Deputy Dawg of Chilcompton&lt;/kennelName&gt;
 &nbsp;&lt;/Dog&gt;
&lt;/rdf:RDF&gt;
</pre></code>
<p>We process this document with a command something like:<br />
<code>java jena.schemagen -i deputy.rdf -b http://example.org/eg#</code><br />
to produce the following generated class:</p>
<code><pre>
/* CVS $Id$ */

import com.hp.hpl.jena.rdf.model.*;

/**
 * Vocabulary definitions from deputy.rdf
 * @author Auto-generated by schemagen on 01 May 2003 21:49
 */
public class Deputy {
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The RDF model that holds the vocabulary terms&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;private static Model m_model = ModelFactory.createDefaultModel();
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabalary as a string {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final String NS = "http://example.org/eg#";
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabalary as a resource {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource NAMESPACE = m_model.createResource( "http://example.org/eg#" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The name that everyone calls a dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property petName = m_model.createProperty( "http://example.org/eg#petName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Posh dogs have a formal name on their KC certificate&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property kennelName = m_model.createProperty( "http://example.org/eg#kennelName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;A class of canine companions&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource Dog = m_model.createResource( "http://example.org/eg#Dog" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Deputy is a particular Dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource deputy = m_model.createResource( "http://example.org/eg#deputy" );
 &nbsp;&nbsp;&nbsp;
}
</pre></code>
<p>Some things to note in this example. All of the named classes, properties and individuals from the source document are translated to Java constants (below we show how to be more selective than this). The properties of the named resources are <i>not</i> translated: schemagen is for giving access to the names in the vocabulary or schema, not to perform a general translation of RDF to Java. The RDFS comments from the source code are translated to Javadoc comments. Finally, we no longer directly call <code>new ResourceImpl</code>: this idiom is no longer recommended by the Jena team.
</p>
<p>We noted earlier that schemagen is highly configurable. One additional argument generates a vocabulary file that uses Jena's ontology API, rather than the RDF model API. We change <code>rdfs:Class</code> to <code>owl:Class</code>, and invoke<br />
<code>java jena.schemagen -i deputy.rdf -b http://example.org/eg# --ontology</code><br />to get:</p>
<p><code><pre>
/* CVS $Id$ */

import com.hp.hpl.jena.rdf.model.*;
import com.hp.hpl.jena.ontology.*;
/**
 * Vocabulary definitions from deputy.rdf
 * @author Auto-generated by schemagen on 01 May 2003 22:03
 */
public class Deputy {
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The ontology model that holds the vocabulary terms&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;private static OntModel m_model = ModelFactory.createOntologyModel( ProfileRegistry.OWL_LANG );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabalary as a string {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final String NS = "http://example.org/eg#";
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The namespace of the vocabalary as a resource {@value}&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Resource NAMESPACE = m_model.createResource( "http://example.org/eg#" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;The name that everyone calls a dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property petName = m_model.createProperty( "http://example.org/eg#petName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Posh dogs have a formal name on their KC certificate&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Property kennelName = m_model.createProperty( "http://example.org/eg#kennelName" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;A class of canine companions&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final OntClass Dog = m_model.createClass( "http://example.org/eg#Dog" );
 &nbsp;&nbsp;&nbsp;
 &nbsp;&nbsp;&nbsp;/** &lt;p&gt;Deputy is a particular Dog&lt;/p&gt; */
 &nbsp;&nbsp;&nbsp;public static final Individual deputy = m_model.createIndividual( Dog, "http://example.org/eg#deputy" );
 &nbsp;&nbsp;&nbsp;
}
</pre></code></p>
<h2>General principles</h2>
<p>In essence, schemagen will load a single vocabulary file (imports processing is switched off in DAML and OWL), and generate a Java class that contains static constants for the named classes, properties and instances of the vocabulary. Most of the generated components of the output Java file can be controlled by option flags, and formatted with a template.  Default templates are provided for all elements, so the minimum amount of necessary information is actually very small.
</p>
<p>
Options can be specified on the command line (when invoking schemagen), or may be preset in an RDF file.  Any mixture of command line and RDF option specification is permitted. Where a given option is specified both in an RDF file and on the command line, the command line setting takes precedence. Thus the options in the RDF file can be seen as defaults.
</p>
<h3>Specifying command line options</h3>
<p>To specify a command line option, add its name (and optional value) to the command line when invoking the schemagen tool. E.g:<br />
<code>java jena.schemagen -i myvocab.owl --ontology --uppercase</code></p>
<h3>Specifying options in an RDF file</h3>
<p>To specify an option in an RDF file, create a resource of type <code>sgen:Config</code>, with properties corresponding to the option names listed in Table 1. The following fragment shows a small options file. A complete example configuration file is shown in <a href="#appendixA">appendix A</a>.
</p>
<p>
By default, schemagen will look for a configuration file named <code>schemagen.rdf</code> in the current directory. To specify another configuration, use the <code>-c</code> option with a URL to reference the configuration. Multiple configurations (i.e. multiple <code>sgen:Config</code> nodes) can be placed in one RDF document.  In this case, each configuration node must be named, and the URI specified in the <code>-r</code> command line option. If there is no <code>-r</code> option, schemagen will look for a node of type <code>rdf:type sgen:Config</code>.  If there are multiple such nodes in the model, it is indeterminite which one will be used.
</p>
<h3>Using templates</h3>
<p>We have several times referred to a template being used to construct part of the generated file. What is a template? Simply put, it is a fragment of output file. Some templates will be used at most once (for example the file header template), some will be used many times (such as the template used to generate a class constant). In order to make the templates adaptable to the job they're doing, before it is written out a template has <em>keyword substitution</em> performed on it.  This looks for certain keywords delimited by a pair of special characters (% by default), and replaces them with the current binding for that keyword. Some keyword bindings stay the same throughout the processing of the file, and some are dependent on the language element being processed. The substitutions are:
</p>
<table width="550" border="1" cellspacing="0" cellpadding="1">
<caption align="bottom">Table 2: Substitutable keywords in templates</caption>
  <tr> <th width="20%">Keyword</th> <th width="40%">Meaning</th> <th width="40%">Typical value</th> </tr>
  <tr> <td>classname</td> <td>The name of the Java class being generated</td> <td>Automatically defined from the document name, or given with the <code>-n</code> option</td> </tr>
  <tr> <td>date</td> <td>The date and time the class was generated</td> <td></td> </tr>
  <tr> <td>imports</td> <td>The Java imports for this class</td> <td></td> </tr>
  <tr> <td>nl</td> <td>The newline character for the current platform</td> <td></td> </tr>
  <tr> <td>package</td> <td>The Java package name</td> <td>As specified by an option. The option just gives the package name, schema gen turns the name into a legal Java statement.</td> </tr>
  <tr> <td>sourceURI</td> <td>The source of the document being processed</td> <td>As given by the <code>-i</code> option or in the config file.</td> </tr>
  <tr> <td>valclass</td> <td>The Java class of the value being defined</td> <td>E.g. Property for vocabulary properties, Resource for classes in RDFS, or OntClass for classes using the ontology API</td> </tr>
  <tr> <td>valcreator</td> <td>The method used to generate an instance of the Java representation</td> <td>E.g. <code>createResource</code> or <code>createClass</code></td> </tr>
  <tr> <td>valname</td> <td>The name of the Java constant being generated</td> <td>This is generated from the name of the resource in the source file, adjusted to be a legal Java identifier. By default, this will preserve the case of the RDF constant, but setting <code>--uppercase</code> will map all constants to upper-case names (a common convention in Java code).</td> </tr>
  <tr> <td>valtype</td> <td>The rdf:type for an individual</td> <td>The class name or URI used when creating an individual in the ontology API</td> </tr>
  <tr> <td>valuri</td> <td>The full URI of the value being defined</td> <td>From the RDF, without adjustment.</td> </tr>
</table>

<h2>Details of schemagen options</h2>
<p>We now go through each of the configuration options in detail.</p>
<p><strong>Note</strong>: for brevity, we assume a standard prefix <code>sgen</code> 
  is defined for resource URI's in the schemagen namespace. The expansion for 
  <code>sgen</code> is: <code>http://jena.hpl.hp.com/2003/04/schemagen#</code>, 
  thus:</p>
<pre>xmlns:sgen=&quot;http://jena.hpl.hp.com/2003/04/schemagen#&quot;</pre>
<h3 id="java_ids">Note on legal Java identifiers</h3>
<p>Schemagen will attempt to ensure that all generated code will compile as legal 
  Java. Occasionally, this means that identifiers from input documents, which 
  are legal components of RDF URI identifiers, have to be modified to be legal 
  Java identifiers. Specifically, any character in an identifier name that is 
  not a legal Java identifier character will be replaced with the character '_' 
  (underscore). Thus the name '<code>trading-price</code>' might become <code>'trading_price</code>'. 
  In addition, Java requires that identifiers be distinct. If a name clash is 
  detected (for example, <code>trading-price</code> and <code>trading+price</code> 
  both map to the same Java identifier), schemagen will add disambiguators to 
  the second and subsequent uses. These will be based on the role of the identifier; 
  for example property names are disambiguated by appending <code>_PROPn</code> 
  for increasing values of <code>n</code>. In a well-written ontology, identifiers 
  are typically made distinct for clarity and ease-of-use by the ontology users, 
  so the use of the disambiguation tactic is rare. Indeed, it may be taken as 
  a hint that refactoring the ontology itself is desireable.</p>
<h3 id="config_file">Specifying the configuration file</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr>
    <td width="140" class="syntaxPrompt">Command line </td>
    <td class="syntax">-c &lt;<i>config-file-path</i>&gt;<br>
      -c &lt;<i>config-file-URL</i>&gt;</td>
  </tr>
  <tr>
    <td class="syntaxPrompt">Config file</td>
    <td class="syntaxPrompt">n/a</td>
  </tr>
</table>
<p>The default configuration file name is <code>schemagen.rdf</code> in the current 
  directory. To specify a different configuration file, either as a file name 
  on the local file system, or as a URL (e.g. an <code>http:</code> address), 
  the config file location is passed with the <code>-c</code> option. If no <code>-c</code> 
  option is given, and there is no configuration file in the current directory, 
  schemagen will continue and use default values (plus the other command line 
  options) to configure the tool. If a file name or URL is given with <code>-c</code>, 
  and that file cannot be located, schemagen will stop with an error.</p>
<h3 id="config_root">Specifying the configuration root in the configuration file</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line </td>
    <td class="syntax">-r &lt;<i>config-root-URI</i>&gt;</td>
  </tr>
  <tr> 
    <td class="syntaxPrompt">Config file </td>
    <td class="syntaxPrompt">n/a</td>
  </tr>
</table>
<p>It is possible to have more than one set of configuration options in one configuration 
  file. If there is only one set of configuration options, schemagen will locate 
  the root by searching for a resource of rdf:type sgen:Config. If there is more 
  than one, and no root is specified on the command line, it is not specified 
  which set of configuration options will be used. The root URI given as a command 
  line option must match exactly with the URI given in the configuration file. 
  For example:</p>
<pre>java jena.schemagen -c config/localconf.rdf -r http://example.org/sg#project1</pre>
<p>matches:</p>
<pre>...
 &lt;sgen:Config rdf:about=&quot;http://example.org/sg#project1&quot;&gt;
   ....
 &lt;/sgen:Config&gt;</pre>
<h3 id="input">Specifying the input document</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td  class="syntax">-i &lt;<i>input-file-path</i>&gt;<br>
      -i &lt;<i>input-URL</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:input rdf:resource=&quot;<i>inputURL</i>&quot; /&gt;</td>
  </tr>
</table>
<p>The only mandatory argument to schemagen is the input document to process. 
  This can be specified in the configuration file, though this does, of course, 
  mean that the same configuration cannot be applied to multiple different input 
  files for consistency. However, by specifying the input document in the default 
  configuration file, schemagen can easily be invoked with the minimum of command 
  line typing. For other means of automating schemagen, see <a href="#ant">using 
  schemagen with Ant</a>. </p>
<h3 id="output">Specifying the output location</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td  class="syntax">-o &lt;<i>input-file-path</i>&gt;<br>
      -o &lt;<i>output-dir</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:output rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>
      output-path-or-dir</i>&lt;/sgen:output&gt;</td>
  </tr>
</table>
<p>Schemagen must know where to write the generated Java file. By default, the 
  output is written to the standard output. Various options exist to change this. 
  The output location can be specified either on the command line, or in the configuration 
  file. If specified in the configuration file, the resource must be a string 
  literal, denoting the file path. If the path given resolves to an existing directory, 
  then it is assumed that the output will be based on the <a href="#class_name">name</a> 
  of the generated class (i.e. it will be the class name with '<code>.java</code>' 
  appended). Otherwise, the path is assumed to point to a file. Any existing file 
  that has the given path name will be overwritten.</p>
<h3 id="output">Specifying the class name</h3>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td  class="syntax">-n &lt;<i>class-name</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:classname rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>
      classname</i>&lt;/sgen:classname&gt;</td>
  </tr>
</table>
<p>By default, the name of the class will be based on the name of the input file. 
  Specifically, the last component of the input document's path name, with the 
  prefix removed, becomes the class name. By default, the initial letter is adjusted 
  to a capital to conform to standard Java usage. Thus <code>file:vocabs/trading.owl</code> 
  becomes <code>Trading.java</code>. To override this default algorithm, a class 
  name specified by <code>-n</code> or in the config file is used exactly as given.</p>
<p>Sometimes it is convenient to have all vocabulary files distinguished by a 
  common suffix, for example <code>xyzSchema.java</code> or <code>xyzVocabs.java</code>. 
  This can be achieved by the classname-suffix option:</p>
<table width="650" border="0" cellspacing="0" cellpadding="1">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td  class="syntax">--classnamesuffix &lt;<i>suffix</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td  class="syntax">&lt;sgen:classnamesuffix rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>
      suffix</i>&lt;/sgen:classnamesuffix&gt;</td>
  </tr>
</table>
<p></p>
<p>See also the <a href="#java_ids">note on legal Java identifiers</a>, which 
  applies to generated class names. </p>
<p></p>
<p></p>
<h3 id="input">Specifying the vocabulary namespace</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">-a &lt;<i>namespace-URI</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:namespace rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>namespace</i>&lt;/sgen:namespace&gt;</td>
  </tr>
</table>
<p>Since ontology files are often modularised, it is not the case that all of 
  the resource names appearing in a given document are being defined by that ontology. 
  They may appear simply as part of the definitions of other terms. Schemagen 
  assumes that there is one primary namespace for each document, and it is names 
  from that namespace that will appear in the generated Java file.</p>
<p>In an OWL or DAML+OIL ontology, this namespace is computed by finding the owl:Ontology 
  or daml:Ontology element, and using its namespace as the primary namespace of 
  the ontology. This may not be available (it is not, for example, a part of RDFS) 
  or correct, so the namespace may be specified directly with the <code>-a</code> 
  option or in the configuration file.</p>
<h3 id="output"></h3>
<p>Schemagen does not, in the present version, permit more than one primary namespace 
  per generated Java class. However, constants from namespaces other than the 
  primary namespace may be included in the generated Java class by the include 
  option:</p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">--include &lt;<i>namespace-URI</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:include rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>namespace</i>&lt;/sgen:include&gt;</td>
  </tr>
</table>
<p></p>
<p>The include option may repeated multiple times to include a variety of constants 
  from other namespaces in the output class.</p>
<h3 id="input_syntax">Specifying the syntax (encoding) of the input document</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">-e &lt;<i>encoding</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:encoding rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>encoding</i>&lt;/sgen:encoding&gt;</td>
  </tr>
</table>
<p>Jena can parse a number of different presentation syntaxes for RDF documents, 
  including RDF/XML, N3 and NTRIPLE. By default, the encoding will be derived 
  from the name of the input document (e.g. a document <code>xyz.n3</code> will 
  be parsed in N3 format), or, if the extension is non-obvious the default is 
  RDF/XML. The encoding, and hence the parser, to use on the input document may 
  be specified by the encoding configuration option.</p>
<h3 id="ontology">Choosing the style of the generated class: ontology or plain RDF</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">--ontology</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:ontology rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;<i>true 
      or false</i>&lt;/sgen:ontology&gt;</td>
  </tr>
</table>
<p>By defaut, the Java class generated by schemagen will generate constants that 
  are plain RDF Resource, Property or Literal constants. When working with OWL 
  or DAML ontologies, it may be more convenient to have constants that are OntClass, 
  ObjectProperty, DatatypeProperty and Individual Java objects. To generate these 
  ontology constants, rather than plain RDF constants, set the ontology configuration 
  option. </p>
<p>Furthermore, since Jena can handle input ontologies in both DAML+OIL and OWL, 
  it is necessary to be able to specify which language is being processed. This 
  will affect both the parsing of the input documents, and the language profile 
  selected for the constants in the generated Java class.</p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">--daml</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:daml rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:daml&gt;</td>
  </tr>
</table>
<p></p>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">--owl</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:owl rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/sgen:owl&gt;</td>
  </tr>
</table>
<p></p>
<h3 id="package">Specifying the Java package</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">--package &lt;<i>package-name</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:package rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>package-name</i>&lt;/sgen:package&gt;</td>
  </tr>
</table>
<p>By defaut, the Java class generated by schemagen will not be in a Java package. 
  Set the package configuration option to specify the Java package name. Note 
  that setting the package name does not affect the directory into which the generated 
  class will be written. The user should specify the appropriate <a href="#output">output 
  directory</a> to match the Java package.</p>
<h3 id="classdec">Additional declarations for the generated class</h3>
<table width="650" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td width="140" class="syntaxPrompt">Command line</td>
    <td class="syntax">--classdec &lt;<i>class-declaration</i>&gt;</td>
  </tr>
  <tr> 
    <td width="140" class="syntaxPrompt">Config file</td>
    <td class="syntax">&lt;sgen:classdec rdf:datatype=&quot;&amp;xsd;string&quot;&gt;<i>class-declaration</i>&lt;/sgen:classdec&gt;</td>
  </tr>
</table>
<p>In some applications, it may be convenient to add additional information to 
  the declaration of the Java class, for example that the class implements a given 
  interface (such as java.lang.Serializable). Any string given as the value of 
  the class-declaration option will be written immediately after &quot;<code>public&nbsp;class&nbsp;<i>ClassName</i></code>&quot;.</p>
<p>&nbsp;</p>

<h2 id="appendixA">Appendix A: Complete example configuration file</h2>
<p>The source of this example is provided in the Jena download as <code>etc/schemagen.rdf</code>.</p>
<p>
  <pre>
<code>&lt;?xml version='1.0'?&gt;

&lt;!DOCTYPE rdf:RDF [
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY jena &nbsp;&nbsp;&nbsp;'http://jena.hpl.hp.com/'&gt;

 &nbsp;&nbsp;&nbsp;&lt;!ENTITY rdf &nbsp;&nbsp;&nbsp;&nbsp;'http://www.w3.org/1999/02/22-rdf-syntax-ns#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY rdfs &nbsp;&nbsp;&nbsp;'http://www.w3.org/2000/01/rdf-schema#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY owl &nbsp;&nbsp;&nbsp;&nbsp;'http://www.w3.org/2002/07/owl#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY xsd &nbsp;&nbsp;&nbsp;&nbsp;'http://www.w3.org/2001/XMLSchema#'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY base &nbsp;&nbsp;&nbsp;'&amp;jena;2003/04/schemagen'&gt;
 &nbsp;&nbsp;&nbsp;&lt;!ENTITY sgen &nbsp;&nbsp;&nbsp;'&amp;base;#'&gt;
]&gt;

&lt;rdf:RDF
 &nbsp;xmlns:rdf &nbsp;&nbsp;="&amp;rdf;"
 &nbsp;xmlns:rdfs &nbsp;="&amp;rdfs;"
 &nbsp;xmlns:owl &nbsp;&nbsp;="&amp;owl;"
 &nbsp;xmlns:sgen  ="&amp;sgen;"
 &nbsp;xmlns &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;="&amp;sgen;"
 &nbsp;xml:base &nbsp;&nbsp;&nbsp;="&amp;base;"
&gt;

&lt;!--
	Example schemagen configuration for use with jena.schemagen
 &nbsp;&nbsp;&nbsp;Not all possible options are used in this example, see Javadoc and Howto for full details.

	Author: Ian Dickinson, mailto:ian.dickinson@hp.com
	CVS: &nbsp;&nbsp;&nbsp;$Id$
--&gt;

&lt;sgen:Config&gt;
 &nbsp;&nbsp;&nbsp;&lt;!-- specifies that the &nbsp;source document uses OWL --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:owl rdf:datatype="&amp;xsd;boolean"&gt;true&lt;/sgen:owl&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- specifies that we want the generated vocab to use OntClass, OntProperty, etc, not Resource and Property --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:ontology rdf:datatype="&amp;xsd;boolean"&gt;true&lt;/sgen:ontology&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- specifies that we want names mapped to uppercase (as standard Java constants) --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:uppercase rdf:datatype="&amp;xsd;boolean"&gt;true&lt;/sgen:uppercase&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- append Vocab to class name, so input beer.owl becomes BeerVocab.java --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:classnamesuffix rdf:datatype="&amp;xsd;string"&gt;Vocab&lt;/sgen:classnamesuffix&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- the java package that the vocabulary is in --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:package rdf:datatype="&amp;xsd;string"&gt;com.example.vocabulary&lt;/sgen:package&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- the directory or file to write the results out to --&gt;
 &nbsp;&nbsp;&nbsp;&lt;sgen:output rdf:datatype="&amp;xsd;string"&gt;src/com/example/vocabulary&lt;/sgen:output&gt;

 &nbsp;&nbsp;&nbsp;&lt;!-- the template for the file header --&gt;
&lt;sgen:header rdf:datatype="&amp;xsd;string"&gt;/*****************************************************************************
 * Source code information
 * -----------------------
 * Original author &nbsp;&nbsp;&nbsp;Jane Smart, example.com
 * Author email &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jane.smart@example.com
 * Package &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@package@
 * Web site &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@website@
 * Created &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%date%
 * Filename &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$RCSfile$
 * Revision &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Revision$
 * Release status &nbsp;&nbsp;&nbsp;&nbsp;@releaseStatus@ $State$
 *
 * Last modified on &nbsp;&nbsp;$Date$
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by &nbsp;&nbsp;$Author$
 *
 * @copyright@
 *****************************************************************************/


// Package
///////////////////////////////////////
%package%


// Imports
///////////////////////////////////////
%imports%



/**
 * Vocabulary definitions from %sourceURI%
 * @author Auto-generated by schemagen on %date%
 */&lt;/sgen:header&gt;

&lt;!-- the template for the file footer (note @footer@ is an ant-ism, will not be processed by VocabGen) --&gt;
&lt;sgen:footer rdf:datatype="&amp;xsd;string"&gt;
/*
@footer@
*/
&lt;/sgen:footer&gt;

&lt;!-- template for extra declarations at the top of the class file --&gt;
&lt;sgen:declarations rdf:datatype="&amp;xsd;string"&gt;
 &nbsp;&nbsp;&nbsp;/** Factory for generating symbols */
 &nbsp;&nbsp;&nbsp;private static KsValueFactory s_vf = new DefaultValueFactory();
&lt;/sgen:declarations&gt;

&lt;!-- template for introducing the properties in the vocabulary --&gt;
&lt;sgen:propSection rdf:datatype="&amp;xsd;string"&gt;
 &nbsp;&nbsp;&nbsp;// Vocabulary properties
 &nbsp;&nbsp;&nbsp;///////////////////////////
&lt;/sgen:propSection&gt;

&lt;!-- template for introducing the classes in the vocabulary --&gt;
&lt;sgen:classSection rdf:datatype="&amp;xsd;string"&gt;
 &nbsp;&nbsp;&nbsp;// Vocabulary classes
 &nbsp;&nbsp;&nbsp;///////////////////////////
&lt;/sgen:classSection&gt;

&lt;!-- template for introducing the individuals in the vocabulary --&gt;
&lt;sgen:individualsSection rdf:datatype="&amp;xsd;string"&gt;
 &nbsp;&nbsp;&nbsp;// Vocabulary individuals
 &nbsp;&nbsp;&nbsp;///////////////////////////
&lt;/sgen:individualsSection&gt;

&lt;!-- template for doing fancy declarations of individuals --&gt;
&lt;sgen:individualTemplate rdf:datatype="&amp;xsd;string"&gt;public static final KsSymbol %valname% = s_vf.newSymbol( "%valuri%" );

 &nbsp;&nbsp;&nbsp;/** Ontology individual corresponding to {@link #%valname%} */
 &nbsp;&nbsp;&nbsp;public static final %valclass% _%valname% = m_model.%valcreator%( %valtype%, "%valuri%" );
&lt;/sgen:individualTemplate&gt;

&lt;/sgen:Config&gt;

&lt;/rdf:RDF&gt;
</code></pre>
</p>
<hr />
<p><small>CVS $Id$</small></p>
</body>
</html>
