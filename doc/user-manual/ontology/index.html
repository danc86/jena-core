<html xmlns="http://www.w3.org/1999/xhtml"><head>
<link rel="stylesheet" href="../../styles/usermanual.css" type="text/css">
<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">


  <title>Jena 2 Ontology tutorial - lesson one</title>
  <link rev="made" href="mailto:ian.dickinson@hp.com" />
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <meta name="generator" content="NoteTab Pro 4.95" />
  <meta name="author" content="Ian Dickinson" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <link href="../../styles/usermanual.css" rel="stylesheet" type="text/css" />
</head>

<body>

<h1>Jena 2 User Manual: The Ontology API</h1>

<p>This section of the user manual describes the Jena2 ontology API in detail, 
  and covers a range of common user tasks. Not all of the fine details of the 
  API are covered here: the reader should expect to refer to the Jena2 Javadoc 
  [TODO] to get the full details of the capabilities of the API.</p>
<p>Note that this is a preliminary version of the manual. Readers should expect 
  that some errors or inconsistencies are possible, and that feedback to the author 
  (<a href="mailto:ian.dickinson@hp.com">email</a>) is welcomed.</p>
<h2>Pre-requisites</h2>
<p>A basic familiarity with RDF and with Jena is assumed; these topics are covered 
  in other documentation if required [TODO]. Jena is a programming toolkit, using 
  the Java programming language. Familiarity with Java programming is also assumed, 
  and is not covered by this documentation.</p>
<h2>Overview</h2>
<p>The section of the manual is broken into a number of sections. It is not necessary 
  to read them in sequence, though later sections may refer to concepts and techniques 
  introduced in earlier sections. The sections are:</p>
<ol>
  <li>Overview</li>
  <li><a href="#generalConcepts">General concepts</a> and ontology languages introduction</li>
  <li><a href="#cameraExample">Running example: the camera ontology</a></li>
  <li><a href="#creatingModels">Creating ontology models</a></li>
  <li><a href="#documentHandling">Handling ontology documents and imports</a></li>
  <li><a href="#classesBasic">Handling ontology components: basic class expressions</a></li>
  <li>Handling ontology components: properties</li>
  <li>Handling ontology components: more complex class expressions</li>
  <li>Ontology meta-data</li>
  <li>Ontology inference: introduction</li>
  <li>Built-in Jena reasoners</li>
  <li>Using external reasoners</li>
  <li>Common problems and other tips</li>
</ol>
<h3>Further assistance</h3>
<p> We hope that this documentation will be sufficient to help most readers to 
  get started using the Jena ontology API. For further support, please post questions 
  to the Jena support list: <a href="TODO">jena-dev@yahoogroups</a>. Bugs may 
  be reported directly to Jena the <a href="TODO">bug tracker</a> on SourceForge. 
  Before reporting a bug, please check that you have downloaded and installed 
  the latest Jena release from [TODO]. </p>
<p>Please note that we prefer that users utilise the support list or the bug-tracker 
  to communicate with the Jena team, rather than emailing the team members directly. 
</p>
<h2 id="generalConcepts">General concepts</h2>
<p>In a widely-quoted definition, an ontology is</p>
<blockquote>
  <p>&quot;... a specification of a conceptualization&quot; [<a href="http://www-ksl.stanford.edu/kst/what-is-an-ontology.html">Gruber, 
    T.</a> 1993]</p>
</blockquote>
<p>Roughly translated, this means that an ontology allows a programmer to specify, 
  in an open, meaningful, way the concepts and relationships that collectively 
  characterise some domain. Examples might be the concepts of red and white wine, 
  grape varieties, vintage years, wineries and so forth that characterise the 
  domain of 'wine', and relationships such as 'wineries produce wines', 'wines 
  have a year of production'. This <i>wine ontology</i> might be developed initially 
  for a particular application, such as a stock-control system at a wine warehouse. 
  As such, it may be considered similar to a well-defined database schema. The 
  advantage to an ontology is that it is an explicit, first-class description. 
  So having been developed for one purpose, it can be published and re-used for 
  other purposes. For example, a given winery may use the wine ontology to link 
  its production schedule to the stock system at the wine warehouse. Alternatively, 
  a wine recommendation program may use the wine ontology, and a description (ontology) 
  of different dishes to recommend wines for a given menu.</p>
<p>There are many ways of writing down an ontology, and a variety of opinions 
  as to what kinds of definition should go in one. In practice, the contents of 
  an ontology are largely driven by the kinds of application it will be used to 
  support. In Jena, we do not take a particular view on the minimal or necessary 
  components of an ontology. Rather, we try to support a variety of common styles 
  of use. This manual explains what is (and to some extent what isn't) possible 
  using Jena's ontology support.</p>
<p>Since Jena is, at heart, an RDF platform, we restrict ourselves to ontology 
  formalisms built on top of RDF. Specifically this means RDFS, the varieties 
  of OWL and DAML+OIL. We provide a very brief introduction to these languages 
  here. Readers should refer to the copious on-line documentation for these formalisms 
  for complete (and authoratative) detail.</p>
<h3>RDFS</h3>
<p>RDFS is the weakest ontology language supported by Jena. RDFS allows the ontologist 
  to build a simple hierarchy of concepts, and a hierarchy of properties. Consider 
  the following trivial characterisation (with apologies to biology-trained readers):</p>
<p class="centered"><img src="../../images/Simple-hierarchy.png" width="372" height="210" alt="image of simple class hierarchy"></p>
<p class="caption">Table 1: A simple concept hierarchy</p>
<p>Using RDFS, we can say that our ontology has five <i>classes</i>, and that 
  <code>Plant</code> is a sub-class of <code>Organism</code> and so on. So every 
  animal is also an organism. A good way to think of these classes is as describing 
  sets of <i>individuals</i>: organism is intended to describe a set of living 
  things, some of which are animals (i.e. a sub-set of the set of organisms is 
  the set of animals), and some animals are fish (a sub-set of the set of all 
  animals is the set of all fish).</p>
<p>To describe the attributes of these classes, we can associate <i>properties</i> 
  with the classes. For example, animals have sensory apparatus (noses, eyes, 
  etc). A general property of an animal might be numSenseOrgans, to denote the 
  number of sensory organs a particular animal has. In general, fish have eyes, 
  so a fish might have a numEyes property. Since eyes are a type of sensory organ, 
  we can capture this relationship between these properties by saying that <code>numEyes</code> 
  is a sub-property-of <code>numSenseOrgans</code>. Thus if a given fish has two 
  eyes, it also has two sense organs. (It may have more, but we know that it must 
  have two). Associating a property with a class is achieved by stating the the 
  property has a given class as its <i>domain</i>, or a given class as its <i>range.</i> 
  Either or both declarations may be given for a given property. For the <code>numEyes</code> 
  example, the domain is <code>Fish</code> and the range is <code>integer</code>.</p>
<p>Describing this simple hierarchy is possible with RDFS. The class hiearchy 
  is not a tree (i.e. not like Java), so a slime mold might be approximated as 
  both a plant and an animal by having both classes among its super-classes. We 
  cannot, in RDFS, state that a thing cannot be a plant and an animal (which is 
  lucky for the slime molds). We can only name the classes, we cannot construct 
  expressions to describe interesting classes. However, for many applications 
  it is sufficient to state the basic vocabulary, and RDFS is perfectly well suited 
  to this.</p>
<p>Note also that we can both describe classes (and their properties), in general 
  terms, and we can describe particular instances of those classes. So there may 
  be a particular individual Fred who is a Fish (i.e. has <code>rdf:type Fish</code>), 
  and who has two eyes. His companion Freda, owing to an unfortunate accident, 
  has only one eye. One use of the ontology is to allow us to fill-in missing 
  information about individuals. Thus, though it is not stated directly, we know 
  that Fred is also an Animal and an Organism. Assume that there was no <code>rdf:type</code> 
  asserting that Freda is a Fish. We may still infer Freda's <code>rdf:type</code> 
  since Freda has <code>numEyes = 1</code>, and in our example the domain of numEyes 
  is Fish - so Freda must be a Fish.</p>
<h3>OWL</h3>
<p>In general, OWL allows us to say everything that RDFS allows, and much more 
  besides. A key part of OWL is the ability to describe classes in more interesting 
  and complex ways. For example, in OWL we can say that Plant and Animal are <i>disjoint 
  classes</i>: no individual can be both a plant and an animal (thus making the 
  poor SlimeMold an empty class). Saltwater fish might be the <i>intersection</i> 
  of Fish and the class SeaDwellers (which also includes, for example, cetaceans 
  and sea plants).</p>
<p>Suppose we have a property <code>hasCovering</code>, intended to represent 
  the scales of a fish or the fur of a mammal. We can now refine the mammal class 
  to be 'animals that have a covering that is hair', using a <i>property restriction</i> 
  to express the condition that property <code>hasCovering</code> has a value 
  from the class <code>Hair</code>. Similarly <code>TropicalFish</code> might 
  be the intersection of the class of <code>Fish</code> and the class of things 
  that have <code>TropicalOcean</code> as their habitat.</p>
<p>Finally (for this brief overview), we can say more about properties in OWL. 
  In RDFS, properties can be related via a property hierarchy. OWL extends this 
  by allowing properties to be denoted as <i>transitive</i>, <i>symmetric</i> 
  or<i> functional</i>, and allow one property to be declared to be the <i>inverse</i> 
  of another. OWL also makes a distinction between properties that have data-values 
  (aka <i>literals</i> in RDF terminology) as their range, or other individuals. 
  Since the domains of properties in RDF are always individuals (aka <i>resources</i> 
  in RDF terminology), this distinction is important since only individual-valued 
  properties, called <i>object properties</i> in OWL can be transitive or symmetric.</p>
<p>The OWL language is divided into three syntax classes: <i>OWL Lite</i>, <i>OWL 
  DL</i> and <i>OWL Full</i>. OWL DL does not permit some constructions allowed 
  in OWL Full, and OWL Lite has all the constraints of OWL DL plus some additional 
  constructions that are not permitted. The intent for OWL Full and OWL DL is 
  to make the task of reasoning with expressions in that subset more tractable. 
  Specifically, OWL DL is intended to be able to be processed efficiently by a 
  <i>description logic</i> reasoner, and OWL Lite by a variety of reasonably simple 
  infererence algorithms.</p>
<p>While the OWL standards documents note that OWL builds on top of the (revised) 
  RDF specifications, it is possible to treat OWL as a separate language in its 
  own right, and not something that is built on an RDF foundation. This view uses 
  RDF as a serialisation syntax; the RDF-centric view treats RDF triples as the 
  core of the OWL formalism. While both views are valid, in Jena we take the RDF-centric 
  view.</p>
<h3>DAML+OIL</h3>
<p>DAML+OIL is very similar to OWL Full. This is not surprising, since the W3C's 
  Web Ontology Working Group, who designed OWL, took DAML+OIL as their starting 
  point. Some constructions in OWL have been added to the capabilities of DAML+OIL, 
  and one or two have been removed. For the purposes of this brief overview, however, 
  the expressiveness of DAML+OIL is comparable to that of OWL.</p>
<h3>Ontology languages and the Jena Ontology API</h3>
<p>Version 1 of Jena had a set of API classes for manipulating ontology information 
  in DAML+OIL (OWL had not yet been invented when Jena 1 was developed). The Jena 
  1 DAML API (henceforth we abbreviate DAML+OIL to DAML) had very little support 
  for reasoning with the semantics of the DAML language. For Jena 2, we wanted 
  a more general capability that would handle a variety of similar languages (specifically, 
  RDFS, DAML and the OWLs), and would work well with Jena 2's new inference capabilities. 
  The ontology API in Jena is the result. </p>
<p>Whereas in the old DAML API, the Java classes were tightly bound to the language 
  being processed (e.g. <code>DAMLClass</code>, <code>DAMLObjectProperty</code>, 
  etc), the ontology API is language-neutral (thus the classes are now <code>OntClass</code> 
  and <code>ObjectProperty</code>). To support this, each of the languages has 
  a <i>profile</i>, which lists the permitted constructs and the URI's of the 
  classes and properties. Thus in the DAML profile, the URI for object property 
  is <code>daml:ObjectProperty</code>, in the OWL profile is it <code>owl:ObjectProperty</code> 
  and in the RDFS profile it is <code>null</code> since RDFS does not define object 
  properties.</p>
<p>The profile is bound to an ontology model, which is an extended version of 
  Jena's Model class. The general Model allows access to the statements in a collection 
  of RDF data. OntModel extends this by adding support for the kinds of objects 
  expected to be in an ontology: classes (in a class hierarchy), properties (in 
  a property hierarchy) and individuals. The properties defined in the ontology 
  langauge map to accessor methods. For example, an <code>OntClass</code> has 
  a method to list its super-classes, which corresponds to the values of the <code>subClassOf</code> 
  property. This point is worth emphasing: no information is stored in the <code>OntClass</code> 
  object itself. When the OntClass <code>listSuperClasses()</code> method is called, 
  the information is retrieved from the underlying RDF statements. Similarly adding 
  a sub-class to an <code>OntClass</code> asserts an additional RDF statement 
  into the model.</p>
<p>The statements that the ontology Java objects see depend on both the asserted 
  statements in the underlying RDF graph, and the statements that can be inferred 
  by the reasoner being used (if any). Consider Figure 2:</p>
<p class="centered"><img src="../../images/Ont-model-layers.png" width="312" height="285" alt="image of layering of graphs in model"></p>
<p class="centered">Figure 2: the statements seen by the OntModel</p>
<p>The asserted statements are held in the base graph. This presents a simple 
  internal interface, <code>Graph</code>. The reasoner, or inference engine, can 
  use the contents of the base graph and the semantic rules of the language, to 
  show a more complete set of statements - i.e. including those that are <i>entailed</i> 
  by the base assertions. This is also presented via the <code>Graph</code> interface, 
  so the model works only with that interface. This allows us to build models 
  with no reasoner, or with one of a variety of different reasoners, without changing 
  the ontology model. It also means that the base graph can be an in-memory store, 
  a database-backed persistent store, or some other storage structure altogether 
  (e.g. an LDAP directory) again without affecting the ontology model.</p>
<h3>RDF-level polymorphism and Java</h3>
<p>Consider the following RDF sample:</p>
<pre>&lt;rdfs:Class rdf:ID=&quot;DigitalCamera&quot;&gt;
&lt;/rdfs:Class&gt;</pre>
<p>This declares that the resource with the (relative) URI #DigitalCamera is an 
  ontology class. It might be appropriate to model declaration in Java with an 
  instance of an <code>OntClass</code>. Now suppose we augment the class declaration 
  with some more information:</p>
<pre>&lt;rdfs:Class rdf:ID=&quot;DigitalCamera&quot;&gt;
  &lt;rdf:type owl:Restriction /&gt;
&lt;/rdfs:Class&gt;</pre>
<p>Now we are saying that <code>#DigitalCamera</code> is an OWL Restriction (which 
  is a sub-class of rdfs:Class, so this is a perfectly consistent operation). 
  The problem we have is that Java does not allow us to dynamically change the 
  Java class of the object modelling this resource. The resource has not changed: 
  it still has URI <code>#DigitalCamera</code>. But the appropriate Java class 
  we might choose to model it has changed from <code>OntClass</code> to <code>Restriction</code>. 
  Conversely, if we remove the <code>rdf:type Restiction</code> from the model, 
  the use of a <code>Restriction</code> Java class is no longer appropriate. </p>
<p>Even worse, OWL Full allows us the following (rather counter-intuitive) construction:</p>
<pre>&lt;rdfs:Class rdf:ID=&quot;DigitalCamera&quot;&gt;
  &lt;rdf:type owl:ObjectProperty /&gt;
&lt;/rdfs:Class&gt;</pre>
<p>That is, <code>#DigitalCamera</code> is now a class <i>and</i> a property. 
  While this may not be a very useful operation, it illustrates a basic point 
  that we cannot rely on a consistent or unique mapping between an RDF resource 
  and the appropriate Java abstraction. In the Jena1 DAML API, we attempted to 
  determine the most-specific Java class for a given DAML object, and create one 
  an instance of that class to model the DAML resource. While having some advantages, 
  this scheme was very brittle and it was easy to construct cases in which it 
  failed.</p>
<p>Jena 2 accepts this basic characteristic of polymorphism at the RDF level by 
  considering that the Java abstraction (OntClass, Restriction, DatatypeProperty, 
  etc) is just a view or <i>facet</i> of the resource. Given a RDF object (i.e. 
  an instance of <code>com.hp.hpl.jena.rdf.model.RDFNode</code> or one of its 
  many sub-classes), we can get a new facet with the <code>as()</code> method. 
  For example:</p>
<pre>Resource r = myModel.getResource( myNS + &quot;DigitalCamera&quot; );
OntClass cls = (OntClass) r.as( OntClass.class );
Restriction rest = (Restriction) cls.as( Restriction.class );</pre>
<p>This pattern allows us to defer until run-time decisions about the correct 
  Java abstraction to use, and make this choice depend on the properties of the 
  resource itself. If a given RDFNode will not support the conversion to a given 
  facet, it will raise an exception. The rather clumsily named <code>canAs()</code> 
  allows a programmer to test whether the <code>as()</code> conversion would work 
  for a given resource.</p>
<p>This RDF-level polymorphism is used extensively in the Jena ontology API to 
  allow maximum flexibility in handling ontology data.</p>
<h2 id="cameraExample">Running example: the camera ontology</h2>
<p>To illustrate the principles of using the Ontology API, we use examples drawn 
  from a <a href="http://www.google.com/search?hl=en&ie=UTF-8&oe=UTF-8&q=Roger%2BCostello%2Bcamera%2Bontology">Roger 
  Costello</a>'s camera <a href="http://www.xfront.com/owl/ontologies/camera/camera.owl">ontology</a>. 
  This ontology arose from a discussion, started by Roger Costello on the RDF 
  mailing lists, about a clear comprehensible example of what was possible with 
  OWL. A copy of the ontology serialised in RDF/XML is included with the Jena 
  download [<a href="data/camera.owl">here</a>].</p>
<p>The camera ontology contains a set of classes describing some aspects of the 
  domain of still-picture cameras, as shown in Figure 3:</p>
<p class="centered"><img src="../../images/Camera-classes.png" width="607" height="346" alt="image of class hierarchy"></p>
<p class="caption">Figure 3: Classes and properties from camera ontology</p>
<p>We will use elements from this ontology to illustrate the ontology API throughout 
  this manual.</p>
<h2 id="creatingModels">Creating ontology models</h2>
<p>An ontology model is an extension of the Jena RDF model that provides extra 
  capabilities for handling ontology data sources. Ontology models are created 
  through the Jena ModelFactory. The simplest way to create an ontology model 
  is as follows:</p>
<pre>OntModel m = ModelFactory.createOntologyModel();</pre>
<p>Since the ontology model is customisable in a number of different ways, this 
  version uses defaults for all of the various parameters. In particular, it uses 
  OWL Full as the ontology language, selects a default reasoner, and assumes that 
  all of the ontology data will be stored in-memory.</p>
<p>To create an ontology model for a particular language, but leaving all of the 
  other values as defaults, specify the URI of the ontology language to the model 
  factory. The URI's for the various language profiles are:</p>
<table width="500" border="1" cellspacing="1" cellpadding="1">
  <tr> 
    <th width="101">Ontology <br>
      language</th>
    <th width="386">URI</th>
  </tr>
  <tr> 
    <td width="101">RDFS</td>
    <td width="386"> 
      <div align="left"><code>http://www.w3.org/2000/01/rdf-schema#</code></div>
    </td>
  </tr>
  <tr> 
    <td width="101">DAML+OIL</td>
    <td width="386"> 
      <div align="left"><code>http://www.daml.org/2001/03/daml+oil#</code></div>
    </td>
  </tr>
  <tr> 
    <td width="101">OWL Full</td>
    <td width="386"> 
      <div align="left"><code>http://www.w3.org/2002/07/owl#</code></div>
    </td>
  </tr>
  <tr> 
    <td width="101">OWL DL</td>
    <td width="386"> 
      <div align="left"><code>http://www.w3.org/TR/owl-features/#term_OWLDL</code></div>
    </td>
  </tr>
  <tr> 
    <td width="101">OWL Lite</td>
    <td width="386"> 
      <div align="left"><code>http://www.w3.org/TR/owl-features/#term_OWLLite</code></div>
    </td>
  </tr>
</table>
<p>These URI's are used to look-up the language profile from the ProfileRegistry. 
  Helpfully, the profile registry contains declared constants that mean that these 
  URI's do not have to be remembered. In particular, the URI's denoting OWL Lite 
  and OWL DL are not officially sanctioned by the WebOnt working group, so may 
  change in future.</p>
<p>To create an ontology model for handling DAML ontologies, use:</p>
<pre>OntModel m = ModelFactory.createOntologyModel( ProfileRegistry.DAML_LANG );</pre>
<p>Beyond these simple choices, the complexity of configuring an ontology model 
  is wrapped up in a recipe object called <code>OntModelSpec</code>. This specification 
  allows complete control over the basic behaviour of the ont model, including 
  the language profile in use, the reasoner, and the means of handling compoud 
  documents. Most conveniently, a number of common recipes are pre-declared as 
  constants in OntModelSpec. For example:</p>
<pre>OntModelSpec.OWL_MEM
OntModelSpec.OWL_MEM_RDFS_INF</pre>
<p>The first of these is describes a model using the OWL Full profile, an in-memory 
  storage model, and no reasoner. The second adds a rule-based reasoner that will 
  add the entailments from the source data using the semantic rules of RDFS only. 
  This will include entailments from sub-class and sub-property hierarchies, and 
  domain and range constraints, but not, for example, entailments from the disjoint-ness 
  of classes. </p>
<p><b>Note:</b> it is the choice of reasoner, <b>not</b> the choice of language 
  profile that determines which entailments are seen by the ontology model. Obviously 
  using the OWL reasoner with DAML source data will result in few additional entailments 
  being seen by the ontology model.</p>
<p>To create a model with a given specification, invoke the ModelFactory as follows:</p>
<pre>OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM, null );</pre>
<p>The significance of the second (null) parameter will be explained below.</p>
<p>To create a custom model specification, we can create a new one from scratch 
  and call the various methods to set the appropriate values. More often, we want 
  only a variation on an existing recipe. In this case, we copy an existing specification 
  and then update the copy as necessary:</p>
<pre>OntModelSpec s = new OntModelSpec( OntModelSpec.OWL_MEM );
s.setDocumentManager( myDocMgr );
OntModel m = ModelFactory.createOntologyModel( s, null );</pre>
<h2 id="documentHandling">Handling ontology documents and imports</h2>
<p>We use the term <i>document</i> to describe an ontology serialised to some 
  transport syntax, such as RDF/XML or N3. We load an ontology document into an 
  ontology model in the same way as a normal Jena model, using the <code>read</code> 
  method. There are several variants on read, that handle differences in the source 
  of the document (to be read from a resolvable URL or directly from an input 
  stream or reader), the base URI that will resolve any relative URI's in the 
  source document, and the serialisation language. In summary, these variants 
  are:</p>
<pre>read( String url )
read( Reader reader, String base )
read( InputStream reader, String base )
read( String url, String lang )
read( Reader reader, String base, String lang )
read( InputStream reader, String base, String lang )</pre>
<p>Any of these methods can be used to load an ontology document. Note that it 
  is suggested that the read variants that use <code>java.io.Reader</code> are 
  avoided when loading XML documents containing internationalised character sets, 
  since the handling of character encoding by the Reader, and the handling of 
  character encoding by XML parsers is not compatible.</p>
<p>Beyond the capability of simply reading documents, the ontology model adds 
  some additional capabilities. First, note that in OWL and DAML+OIL, it is possible 
  for ontologies to be treated as re-usable modules and imported into different 
  documents. An OWL or DAML document may contain an individual of class Ontology, 
  which contains meta-data about that document itself:</p>
   <pre>&lt;owl:Ontology rdf:about=&quot;&quot;&gt;
  &lt;dc:creator rdf:value=&quot;Ian Dickinson&quot; /&gt;
  &lt;owl:imports rdf:resource=&quot;http://jena.hpl.hp.com/example-ont&quot; /&gt; 
&lt;/owl:Ontology&gt; </pre>
<p>The construct <code>rdf:about=&quot;&quot;</code> is a relative URI that will 
  resolve to the document's base URI: in other words it's a shorthand way of referring 
  to self. The <code>owl:imports</code> line (an equivalent term exists for DAML) 
  states that this ontology is constructed using terms (i.e. classes and properties) 
  from the given ontology. In order to properly evaluate the terms in this ontology, 
  we should have available the terms from the imported source.</p>
<p>The ontology DocumentManager is a helper class for OntModel that assists with 
  handling such imports. Before discussing it further, we need to update Figure 
  2 to show how imported documents are handled:</p>
<p class="centered"><img src="../../images/Ont-model-layers-import.png" width="563" height="331"></p>
<p class="caption">Figure 4: ontology internal structure including imports</p>
<p>We see that each imported ontology document is held in a separate graph structure. 
  This is important: if we did not do this, once the imports had been processed 
  it would be impossible to know where a statement came from. This was in fact 
  the case with the Jena 1 DAML API, and this new design eases the considerable 
  problems this caused. When this structure is built by the ontology model (processing 
  the imports is handled automatically by the document manager), the original 
  or base graph has a distinguished role. It is this graph that is updated when 
  statements are added to, or removed from, the ontology model. It is also this 
  graph whose contents are serialised when the model is written.</p>
<p>Imports are processed recursively, so if our base document imports ontology 
  A, and A imports B, we will end up with the structure shown in Figure 4. The 
  occurs check is used to prevent the document manager getting stuck if B also 
  imports A!</p>
<h3>The ontology document manager</h3>
<p>Each ontology model has an associated document manager that assists with the 
  processing and handling of ontology documents. For convenience, there is one 
  global document manager that is used by default by ontology models. This shared 
  instance is accessible via <code>OntDocumentManager.getInstance()</code>. In 
  many cases, it will be sufficient to simply change the settings on the global 
  document manager to suit a given application's needs. However, for more fine-grain 
  control, separate document managers may be constructed and passed to the ontology 
  model when it is created through the model factory. This is achieved by creating 
  (or adapting) an ontology specification object, and setting the document manager 
  attribute, for example:</p>
<pre>OntDocumentManager mgr = new OntDocumentManager();<br>// set the mgr's properties now ...
OntModelSpec s = new OntModelSpec( OntModelSpec.RDFS_MEM );
s.setDocumentManager( mgr );
OntModel m = ModelFactory.createOntologyModel( s, null );</pre>
<p>Note that the model retains a reference to the document manager it was created 
  with. Thus changing a document manager's properties will affect models that 
  have previously been constructed with that document manager.</p>
<h3>Document manager policy</h3>
<p>Since the document manager has a large number of configurable options, there 
  are two ways in which it can be customised to application requirements. Firstly, 
  the individual parameters of the document manager can be set by Java code. Alternatively, 
  when a given document manager is created it can load values for the various 
  parameters from a policy file, expressed in RDF. The document manager has a 
  list of URL's on which it will search for a policy document. It will stop at 
  the first entry on the list that resolves to a retrievable document. The default 
  search path for the policy is: <code>file:etc/ont-policy.rdf;file:ont-policy.rdf</code>. 
  Thus the default policy, which can serve as a template for user-defined policies, 
  can be found in the <code>etc/</code> directory under the Jena download directory.</p>
<p>General properties of the document manager are set in the policy as properties 
  on a DocumentManagerPolicy object as follows:</p>
<pre>&lt;DocumentManagerPolicy&gt;
  &lt;!-- policy for controlling the document manager's behaviour --&gt;
  &lt;processImports rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/processImports&gt;
  &lt;cacheModels rdf:datatype=&quot;&amp;xsd;boolean&quot;&gt;true&lt;/cacheModels&gt;
&lt;/DocumentManagerPolicy&gt;</pre>
<p>The (simple) ontology that declares the various properties that can be used 
  in such a policy is available in the vocabularies directory in the Jena download, 
  see <code>ont-manager.rdf</code>.</p>
<p>To change the search path that the document manager will use to initialise 
  itself, either pass the new search path as a string when creating a new document 
  manager object, or call the method <code>setMetadataSearchPath</code>.</p>
<p></p>
<h3>The ModelMaker parameter of the document manager</h3>
<p>In order for the document manager to build the union of the imported documents 
  (which we refer to as the <i>imports closure</i>), it must be able to create 
  new graphs to store the imported ontologies. A parameter of the document manager 
  is its <i>model maker</i>. The model maker is a simple interface that allows 
  different kinds of models (in memory, from file, in persistent database, etc) 
  to be built on demand. For the database case, this may include passing the database 
  user-name and password and other connection parameters. New model makers can 
  be created via <code>ModelFactory</code>. The default specifications in OntModelSpec 
  that begin MEM_ use an in-memory model for the base model, and use a memory 
  model maker to store the imported ontologies in in-memory models.</p>
<p><b>Note</b>: internally to Jena, we use the Graph as a primary data structure. 
  However, user code will almost always refer to models, not graphs. A model wraps 
  a graph, and provides convenience methods for accessing the contents of the 
  graph. Hence Figure 4, above, refers to a structure containing graphs, but we 
  use a <code>ModelMaker</code> to generate new stores. The document manager extracts 
  the appropriate graph from the containing model.</p>
<h3>Controlling imports processing</h3>
<p>To load an ontology without building the imports closure, call the method <code>setProcessImports(&nbsp;false&nbsp;)</code> 
  on the document manager object, or set the <code>processImports</code> property 
  in the policy file. To be more selective, it is possible to ignore certain URI's 
  when loading the imported documents. Call the method <code>addIgnoreImport(&nbsp;String&nbsp;uri&nbsp;)</code> 
  on the document manager object, or set the <code>ignoreImport</code> property 
  in the policy.</p>
<p>A strength of working with ontologies is that we can re-use work done by other 
  ontologists by importing their published ontologies. Often, however, this means 
  that the ontology is only retrievable by traversing an Internet firewall. Even 
  if this is possible, by using an HTTP proxy, it may impose unacceptable delay 
  in loading an application. In the worst case, an ontology on which our application 
  depends is temporarily or permanently unavailable from the original published 
  URL. To assist with this common problem, the ontology document manager allows 
  a local indirection, so that an attempt to import a document from a given published 
  URL means that a local copy of the document is retrieved instead. This may be 
  a file copy or simply duplicated on an internal mirror web site.</p>
<p>To specify this local re-direction in the policy file, we use the following 
  declarations:</p>
<pre>&lt;OntologySpec&gt;
  &lt;!-- local version of the RDFS vocabulary --&gt;
  &lt;publicURI rdf:resource=&quot;http://www.w3.org/2000/01/rdf-schema&quot;    /&gt;
  &lt;altURL rdf:resource=&quot;file:vocabularies/rdf-schema.rdf&quot; /&gt;
  &lt;language rdf:resource=&quot;http://www.w3.org/2000/01/rdf-schema&quot; /&gt;
  &lt;prefix rdf:datatype=&quot;&amp;xsd;string&quot;&gt;rdfs&lt;/prefix&gt;
&lt;/OntologySpec&gt;</pre>
<p>This specifies that an attempt to load the RDFS vocabulary from <code>http://www.w3.org/2000/01/rdf-schema</code> 
  will transparently cause <code>file:vocabularies/rdf-schema.rdf</code> to be 
  fetched instead. Any number of such re-directions may be specified in the policy 
  file, or they can be added to the document manager object directly by calling 
  the various 'add' methods (see the Javadoc for details). As a side-effect, this 
  mechanism also means that ontologies can be named with any legal URI (not necessarily 
  resolvable) - so long as the altURL is itself resolvable.</p>
<h3>Specifying prefixes</h3>
<p>A model keeps a table of URI prefixes that can be used to render URI's in the 
  shortened prefix:name form, which is useful in displaying URI's in a readable 
  way in user interfaces, and is essential in producing legal XML names that denote 
  arbitrary URI's. The ontology model's table of prefixes can be initialised from 
  a table kept by the document manager, which contains the standard prefixes plus 
  any that are declared by in the policy file (or added to subsequently by method 
  calls). To prevent the model's prefix table from being initialised in this way, 
  use the property <code>useDeclaredNsPrefixes</code> in the policy file (with 
  value 'false'), or call the method <code>setUseDeclaredPrefixes</code> on the 
  ontology object.</p>
<h3>Caching models</h3>
<p>The final behaviour that the document manager provides to assist with loading 
  ontology documents is a model cache. Suppose two ontologies, A and B both import 
  ontology C. It would be nice not to have to read C twice when loading A and 
  B. The document manager supports this use case by optionally caching C's model, 
  indexed by C's URI. Then an attempt to import C from B, it previously having 
  been loaded by A, would result in a significant time saving, and a re-use of 
  the same model for C in both A and B. </p>
<p>To turn model caching on or off, use the policy property <code>cacheModels</code>, 
  or call the method <code>setCacheModels(&nbsp;boolean&nbsp;caching&nbsp;)</code>. 
  The default is caching on. The document manager's current model cache can be 
  cleared at any time by calling <code>clearCache()</code>.</p>
<h3>Example</h3>
<p>In the following example, we programmatically declare that the camera ontology 
  is copied locally, and then load it using the public URL. Assume that the constant 
  JENA has been initialised to the directory in which Jena is installed.</p>
<pre>OntModel m = ModelFactory.createOntologyModel();
OntDocumentManager dm = m.getDocumentManager();
dm.addAltEntry( &quot;http://www.xfront.com/owl/ontologies/camera/&quot;,
                &quot;file:&quot; + JENA + &quot;doc/user-manual/ontology/data/camera.owl&quot;    );
m.read( &quot;http://www.xfront.com/owl/ontologies/camera/&quot; );</pre>
<h2>Handling ontology components: basic class expressions</h2>
<p>&nbsp;</p>
</body>
</html>
