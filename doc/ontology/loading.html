<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="CONTENT-TYPE" content="text/html; charset=us-ascii" />
    <title>
      Loading and importing ontology documents
    </title>
  </head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#a0a0ff">
      <tr valign="top">
        <td width="33%">
          &laquo; previous (none)
        </td>
        <td width="33%" align="center">
          <a href="index.html">^ up</a> (overview)
        </td>
        <td width="33%" align="right">
          (API classes) <a href="api.html">next &raquo;</a>
        </td>
      </tr>
    </table>
    <h2>
      Loading and Importing Ontology Documents
    </h2>
    <p>
      In OWL and DAML+OIL, an ontlogy serialised in RDF/XML can import definitions from another document. This is achived with the <code>owl:imports</code> property in OWL, and <code>daml:imports</code> in DAML+OIL. Imports are processed recursively, so a document A that imports document B, where B itself imports C, would normally be expected to contain the declarations from both B and C after loading. Imports are declared in a document as part of the Ontology node, that provides meta-data about that ontology document. For example, in OWL:
    </p>
    <code><pre>
&lt;owl:Ontology rdf:about=""&gt;
   &lt;owl:imports rdf:about="http://jena.hpl.hp.com/examples/example"&gt;
&lt;/owl:Ontology&gt;
    </pre></code>

    <p>
      or in DAML+OIL:
    </p>
    <code><pre>
&lt;daml:Ontology rdf:about=""&gt;
   &lt;daml:imports rdf:about="http://jena.hpl.hp.com/examples/example"&gt;
&lt;/daml:Ontology&gt;
    </pre></code>
    <p>
      In Jena1, if a DAML ontology document was loaded, and imports processing was switched on (which was the default), the imported documents would be loaded automatically into the DAMLModel. This was convenient for simple applications, but suffered from a lack of flexibility. A particular issue was that all of the imported declarations were placed in one model. Thus, loading a model with imports processing turned on, making some changes and then writing the document out again would result in a serialisation of the entire imports closure. This is clearly not desireable, as it breaks the modularisation of the ontologies.
    </p>
    <p>
      In Jena2 we have a different approach. An ontology model is assumed to have an underlying RDF graph that is a <i>union</i>&nbsp;of the graphs corresponding to each of the imported documents. Thus, if document A imports B and C, we have the following:
    </p>
    <p>
      <!--img src="loading_html_71c5a324.gif" name="Graphic1" align="left" border="0" /><br clear="left" /-->
       <img src="imports-structure.png" border="0" alt="loading_html_71c5a324" bgcolor="white" /><br><i>Figure1 Composition of union graphs for an OntModel</i>
    </p>
    <p>
      The union graph, that defines the contents of the ontology model, presents a uniform view of the RDF statements from any of the subsidiary component graphs. Thus a query or <code>listStatements</code> on the model will return results from the initial document, or any of its imports. Notice that one of the leaf graphs is distinguished. This is the graph that will receive updates, so any statements added to the model will automatically be made to this writeable graph. By default, the writeable graph is the graph corresponding to the initially loaded model, though this can be changed by the user.
    </p>
    <p>
      This explanation is provided to assist Jena users to understand the underlying processes when an ontology is loaded. For many uses, user code will not need to take any special action to achieve robust handling of imported documents. Import processing is handled automatically by the standard <code>Model.read()</code> family of access methods. For more advanced uses, see below.
    </p>
    <h3>
      Managing source documents with the ontology document manager
    </h3>
    <p>
      A common scenario when constructing modular ontologies is to re-use an ontology provided by another team, which is typically published on the WWW. Indeed, many of the proposed uses of the Semantic Web depend on this public sharing. Two factors inhibit direct access to web-readable ontologies: speed of access, and traversing firewalls. Firstly, when starting up an application, the delay in accessing a remote web site (which, in the limit, may even be inaccessible for a variety of reasons) can place an intolerable burden upon the users of the application. Secondly, for good reasons of information security, corporate and other institutional users are often protected from direct access to the WWW by a firewall. We would like to be able to gain the benefits of re-using published ontologies, without the need for access to the open Internet, and at acceptable speeds.
    </p>
    <p>
      Jena2 has an Ontology Document Manager that provides a mechanism for accessing locally stored copies of an ontology document via its public URL. For example, suppose an application wants to re-use the ontology published at <code>http://jena.hpl.hp.com/examples/ex</code><a href="http://jena.hpl.hp.com/examples/ex">.</a> The developer has downloaded from the Jena team web site a copy of the ontology, and stored it locally as <code>file:downloads/jena/ex.owl</code>. To inform the document manager that it should load this local copy, in place of the public URL, the following is added to an RDF configuration file:
    </p>
    <code><pre>
&lt;OntologySpec&gt;
        &lt;publicURI rdf:resource="http://jena.hpl.hp.com/examples/ex" /&gt;
        &lt;altURL    rdf:resource="file:downloads/jena/ex.owl" /&gt;
        &lt;language  rdf:resource="http://www.w3.org/2002/07/owl" /&gt;
&lt;/OntologySpec&gt;
    </pre></code>
    <p>
      The RDF file containing this and other configations is searched for along a path given to the OntDocumentManager class. By default, this path is:
    </p>
    <p>
      <code>etc/ont-policy.rdf;./ont-policy.rdf</code>
    </p>
    <p>
      but this can be changed easily by user code.
    </p>
    <p>
      For convenience, a single global document manager is accessible by calling <code>OntDocumentManager.getInstance()</code>. However, the document manager is not a singleton, and individual instances of it may be created and passed to the OntModel constructor via the <code>ModelFactory</code>.
    </p>
    <h3>
      Managing the imports closure with the document manager
    </h3>
    <p>
      Each ontology model is bound to a document manager. By default, they will all share a reference to the global default ontology manager (see above). The document manager provides additional facilities for fine-grain control over the imports process.
    </p>
    <table width="800" border="1" cellpadding="2" cellspacing="3" >
      <thead>
        <tr valign="top">
          <th width="425">
            <p>
              Document Manager Method
            </p>
          </th>
          <th width="356">
            <p>
              Explanation
            </p>
          </th>
        </tr>
      </thead>
      <tbody>
        <tr valign="top">
          <td width="425">
            <p>
              <code>void setProcessImports( boolean process )<br />
               boolean getProcessImports()</code>
            </p>
          </td>
          <td width="356">
            <p>
              Get or set a flag to control whether imports are processed at all
            </p>
          </td>
        </tr>
        <tr valign="top">
          <td width="425">
            <p>
              <code>void setCacheGraphs( boolean cache )<br />
               boolean getCacheGraphs()</code>
            </p>
          </td>
          <td width="356">
            <p>
              Get or set a flag to control whether the association between a document URI and the resulting graph is recorded. If set, subsequent loading of that document URI will return the cached graph. This potentially speeds up the importing of complex sets of ontologies, against the standard risks that caches become stale.
            </p>
          </td>
        </tr>
        <tr valign="top">
          <td width="425">
            <p>
              <code>Graph getGraph( String uri )</code>
            </p>
          </td>
          <td width="356">
            <p>
              Get the cached graph for the given URI, if known, or null if not.
            </p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3>
      Updating and writing an OntModel with imports
    </h3>
    <p>
      As noted above, a key problem with imports handling in Jena1 was the aggregation of all imported data into one model. Jena2 solves this by using a union of individual graphs to hold the imported statements. The following code sample shows how to load a model, update it, and write out only the changed portion.
    </p>
    <pre>
<code>// first create a default model
OntModel m = ModelFactory.createOntologyModel();

// now read the document in; will also load imports
m.read( "http://example.com/ontologies/eg" );

// add a statement to the updateable model
m.addStatement( s, p, 42 );

// write the portion of the model that has changed
m.getBaseModel().write( System.out );
</code>
    </pre>
    <p>
    </p>
    <table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#a0a0ff">
      <tr valign="top">
        <td width="33%">
          &laquo; previous (none)
        </td>
        <td width="33%" align="center">
          <a href="index.html">^ up</a> (overview)
        </td>
        <td width="33%" align="right">
          (API classes) <a href="api.html">next &raquo;</a>
        </td>
      </tr>
    </table>
  </body>
</html>
