<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
	<META NAME="CREATED" CONTENT="20030407;13231900">
	<META NAME="CHANGED" CONTENT="20030407;22121900">
</HEAD>
<BODY LANG="en-GB">
<TABLE WIDTH=100% BORDER=0 CELLPADDING=0 CELLSPACING=0 STYLE="page-break-before: always">
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>&laquo; previous (none)</P>
		</TD>
		<TD WIDTH=33%>
			<P ALIGN=CENTER><A HREF="index.html/">^ up</A> (overview)</P>
		</TD>
		<TD WIDTH=33%>
			<P ALIGN=RIGHT>(API classes)  <A HREF="api.html/">next &raquo;</A></P>
		</TD>
	</TR>
</TABLE>
<H2>Loading and Importing Ontology Documents</H2>
<P>In OWL and DAML+OIL, an ontlogy serialised in RDF/XML can import
definitions from another document. This is achived with the
<CODE>owl:imports</CODE> property in OWL, and <CODE>daml:imports</CODE>
in DAML+OIL. Imports are processed recursively, so a document A that
imports document B, where B itself imports C, would normally be
expected to contain the declarations from both B and C after loading.
Imports are declared in a document as part of the Ontology node, that
provides meta-data about that ontology document. For example, in OWL:</P>
<PRE>&lt;owl:Ontology rdf:about=””&gt;
   &lt;owl:imports rdf:about=”<A HREF="http://jena.hpl.hp.com/examples/example">http://jena.hpl.hp.com/examples/example</A>” /&gt;
&lt;/owl:Ontology&gt;</PRE><P STYLE="margin-bottom: 0cm">
or in DAML+OIL:</P>
<PRE>&lt;daml:Ontology rdf:about=””&gt;
   &lt;daml:imports rdf:about=”<A HREF="http://jena.hpl.hp.com/examples/example">http://jena.hpl.hp.com/examples/example</A>” /&gt;
&lt;/daml:Ontology&gt;</PRE><P STYLE="margin-bottom: 0cm">
In Jena1, if a DAML ontology document was loaded, and imports
processing was switched on (which was the default), the imported
documents would be loaded automatically into the DAMLModel. This was
convenient for simple applications, but suffered from a lack of
flexibility. A particular issue was that all of the imported
declarations were placed in one model. Thus, loading a model with
imports processing turned on, making some changes and then writing
the document out again would result in a serialisation of the entire
imports closure. This is clearly not desireable, as it breaks the
modularisation of the ontologies.</P>
<P>In Jena2 we have a different approach.
An ontology model is assumed to have an underlying RDF graph that is
a <I>union</I>&nbsp;of the graphs corresponding to each of the
imported documents. Thus, if document A imports B and C, we have the
following:</P>
<P><SPAN ID="Frame1" STYLE="width: 17.88cm; height: 8.52cm; border: none; padding: 0cm; background: #ffffff">
	<P STYLE="margin-top: 0.21cm; margin-bottom: 0.21cm"><IMG SRC="loading_html_71c5a324.gif" NAME="Graphic1" ALIGN=LEFT BORDER=0><BR CLEAR=LEFT><I>Figure1 Composition of union graphs for an OntModel</I></P>
</SPAN><p>The union graph, that defines the contents of
the ontology model, presents a uniform view of the RDF statements
from any of the subsidiary component graphs. Thus a query or
<CODE>listStatements</CODE> on the model will return results from the
initial document, or any of its imports. Notice that one of the leaf
graphs is distinguished. This is the graph that will receive updates,
so any statements added to the model will automatically be made to
this writeable graph. By default, the writeable graph is the graph
corresponding to the initially loaded model, though this can be
changed by the user. 
</P>
<P>This explanation is provided to assist
Jena users to understand the underlying processes when an ontology is
loaded. For many uses, user code will not need to take any special
action to achieve robust handling of imported documents. Import
processing is handled automatically by the standard <CODE>Model.read()</CODE>
family of access methods. For more advanced uses, see below.</P>
<H3>Managing source documents with the ontology document manager</H3>
<P>A common scenario when constructing modular ontologies is to
re-use an ontology provided by another team, which is typically
published on the WWW. Indeed, many of the proposed uses of the
Semantic Web depend on this public sharing. Two factors inhibit
direct access to web-readable ontologies: speed of access, and
traversing firewalls. Firstly, when starting up an application, the
delay in accessing a remote web site (which, in the limit, may even
be inaccessible for a variety of reasons) can place an intolerable
burden upon the users of the application. Secondly, for good reasons
of information security, corporate and other institutional users are
often protected from direct access to the WWW by a firewall. We would
like to be able to gain the benefits of re-using published
ontologies, without the need for access to the open Internet, and at
acceptable speeds.</P>
<P>Jena2 has an Ontology Document Manager that provides a mechanism
for accessing locally stored copies of an ontology document via its
public URL. For example, suppose an application wants to re-use the
ontology published at <CODE>http://jena.hpl.hp.com/examples/ex</CODE><A HREF="http://jena.hpl.hp.com/examples/ex">.</A>
The developer has downloaded from the Jena team web site a copy of
the ontology, and stored it locally as <CODE>file:downloads/jena/ex.owl</CODE>.
To inform the document manager that it should load this local copy,
in place of the public URL, the following is added to an RDF
configuration file:</P>
<PRE>&lt;OntologySpec&gt;
        &lt;publicURI rdf:resource=&quot;http://jena.hpl.hp.com/examples/ex&quot; /&gt;
        &lt;altURL    rdf:resource=&quot;file:downloads/jena/ex.owl&quot; /&gt;
        &lt;language  rdf:resource=&quot;http://www.w3.org/2002/07/owl&quot; /&gt;
&lt;/OntologySpec&gt;</PRE><P STYLE="font-style: normal">
The RDF file containing this and other configations is searched for
along a path given to the OntDocumentManager class. By default, this
path is:</P>
<P><CODE>etc/ont-policy.rdf;./ont-policy.rdf</CODE></P>
<P STYLE="font-style: normal">but this can be changed easily by user
code.</P>
<P>For convenience, a single global document manager is accessible by
calling <CODE>OntDocumentManager.getInstance()</CODE>. However, the
document manager is not a singleton, and individual instances of it
may be created and passed to the OntModel constructor via the
<CODE>ModelFactory</CODE>.</P>
<H3>Managing the imports closure with the document manager</H3>
<P>Each ontology model is bound to a document manager. By default,
they will all share a reference to the global default ontology
manager (see above). The document manager provides additional
facilities for fine-grain control over the imports process.</P>
<TABLE WIDTH=800 BORDER=1 CELLPADDING=2 CELLSPACING=3>
	<COL WIDTH=425>
	<COL WIDTH=356>
	<THEAD>
		<TR VALIGN=TOP>
			<TH WIDTH=425>
				<P>Document Manager Method</P>
			</TH>
			<TH WIDTH=356>
				<P>Explanation</P>
			</TH>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=425>
				<P><CODE>void setProcessImports( boolean process )<BR>boolean
				getProcessImports()</CODE></P>
			</TD>
			<TD WIDTH=356>
				<P>Get or set a flag to control whether imports are processed at
				all</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=425>
				<P><CODE>void setCacheGraphs( boolean cache )<BR>boolean
				getCacheGraphs()</CODE></P>
			</TD>
			<TD WIDTH=356>
				<P>Get or set a flag to control whether the association between a
				document URI and the resulting graph is recorded. If set,
				subsequent loading of that document URI will return the cached
				graph. This potentially speeds up the importing of complex sets
				of ontologies, against the standard risks that caches become
				stale.</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=425>
				<P><CODE>Graph getGraph( String uri )</CODE></P>
			</TD>
			<TD WIDTH=356>
				<P>Get the cached graph for the given URI, if known, or null if
				not.</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<H3>Updating and writing an OntModel with imports</H3>
<P>As noted above, a key problem with imports handling in Jena1 was
the aggregation of all imported data into one model. Jena2 solves
this by using a union of individual graphs to hold the imported
statements. The following code sample shows how to load a model,
update it, and write out only the changed portion.</P>
<PRE>// first create a default model
OntModel m = ModelFactory.createOntologyModel();

// now read the document in; will also load imports
m.read( “<A HREF="http://example.com/ontologies/eg">http://example.com/ontologies/eg</A>” );

// add a statement to the updateable model
m.addStatement( s, p, 42 );
// write the portion of the model that has changed
m.getWriter().write( m.getBaseGraph() ); // TODO check this</PRE><P>
<BR><BR>
</P>
</BODY>
</HTML>
