<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="CONTENT-TYPE" content="text/html; charset=us-ascii" />
    <title>
      Using the ontology API
    </title>
  </head>
  <body>
    <table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#a0a0ff">
      <tr valign="top">
        <td width="33%">
          <a href="loading.html">&laquo; previous</a> (loading and importing)
        </td>
        <td width="33%" align="center">
          <a href="index.html">^ up</a> (overview)
        </td>
        <td width="33%" align="right">
          (inference) <a href="inference.html">next &raquo;</a>
        </td>
      </tr>
    </table>
    <h2>
      Using the ontology API classes
    </h2>
    <p>
    In this section, we introduce the main concepts behind the Jena2 ontology API. This overview does not detail
    all of the capabilities of the API, in part because it is still evolving.  Consult the Javadoc for more details.
    </p>
    <h3>Introducing polymorphic resources</h3>
    <p>
    In Jena 1, a resource in a DAML model was inspected at load time to determine which type of resource it was, and
    an appropriate Java class was instantiated to represent that resource in the loaded model.  Once created, there
    was no convenient way of changing the resource class that was used.  Moreover, Java's restrictions mean that there
    are limitations on the ways that class types are combined. This caused problems in Jena 1. For example, the following
    fragment of DAML code appears to specify an instance of a class:
    </p>
    <code><pre>
      &nbsp;&nbsp;&nbsp;&lt;ex:Colour rdf:ID="red"&gt;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ex:rgb rdf:value="ff0000" /&gt;
      &nbsp;&nbsp;&nbsp;&lt;/ex:Colour&gt;
    </pre></code>
    <p>
    However, if <code>ex:Colour</code> was not (at the time of loading) the URI of a DAML class known to the DAML loader,
    the loader would leave the resource as a simple RDF resource, instead of making it a <code>DAMLInstance</code>. This
    approach also had problems with ontologies that treat classes as instances, and with DAML models that were dynamically
    updated to change the entailments for a resource (for example by adding an <code>rdf:type</code> statement).
    </p>
    <p>
     Jena 2 provides a new mechanism for supporting <em>polymorphism</em> of RDF resources. In essence, the API call
     <code>.as(&nbsp;other&nbsp;)</code> attempts to construct a polymorphic view of any RDF node, presenting it
     as some other view determined by <code>other</code>. The <code>other</code> parameter is simply the Java class
     of the required view.  Thus, if r is some resource, we can view r as an ontology class object (<code>OntClass</code>
     is a generalisation of the old class <code>DAMLClass</code> from Jena 1) as follows:
    </p>
    <code><pre>
        Resource r = .... ;
        OntClass c = (OntClass) r.as( OntClass.class );
    </pre></code>
    <p>
    This conversion can be performed at any time, which immediately addresses one of the problems with the Jena 1 DAML
    loader approach.  There is no limit to the number of alternative views of a resource that can be created, provided that
    the model currently supports those interpretations.  Thus a resource can be simultaneously viewed as both a class
    and an instance, providing that the model contains the corresponding <code>rdf:type</code> statements.
    </p>
    <h3>The Jena ontology API abstractions</h3>
    <p>
    The ontology API provides a number of abstractions as Java classes, that correspond to the classes declared in the
    OWL and DAML+OIL languages.  These classes have accessor methods corresponding to the properties declared in those
    languages.  Where OWL and DAML+OIL use different names for the same basic concept, we have chosen to use the name
    from OWL as the name for the corresponding Java class or accessor.
    </p>
    <p>
    <strong>Language profiles</strong> In Jena 1, the abstractions in the API were named "DAMLClass", "DAMLProperty", etc.
    This design choice binds the abstractions to a particular ontology language (DAML+OIL in this case). Rather than create
    a parallel set of "OWLClass", "OWLProperty", ..., classes in Jena 2, we have sought to generalise away from the specifics
    of the language used (which is only possible because DAML+OIL and OWL are actually fairly similar).  The API thus
    defines abstractions with language-neutral names: "OntClass", "Restriction", "TransitiveProperty", etc.  To use these
    abstractions with ontology data encoded in a given language, a <em>language profile</em> is bound to a particular
    ontology model. The language profile defines the URI's of the names used in the language.  Thus, OntClass used with
    the OWL language profile will look for resourcs with <code>rdf:type</code> <code>http://www.w3.org/2002/07/owl#Class</code>,
    whereas an OntClass in a model bound to the DAML language profile will look for resources typed with
    <code>http://www.daml.org/2001/03/daml+oil#Class</code>.  The language profile also encodes which terms are not present
    in a given language (DAML, for example, has no concept of a SymmetricProperty).
    </p>
    <p>
    To create an ontology model, the appropriate language must be specified.  The ProfileRegistry [todo link] allows
    language profiles to be associated with their public URI's. It also defines constants to assist with creating
    ontology models via the model factory.  The following code is used to create an OWL model and a DAML model respectively:
    <code><pre>
        OntModel owlModel = ModelFactory.createOntologyModel( ProfileRegistry.OWL_LANG );
        OntModel owlModel = ModelFactory.createOntologyModel( ProfileRegistry.DAML_LANG );
    </code></pre>
    </p>
    <p>
    <i>TODO: more here on the various API classes, also on property accessors. Ont resources as resources.</i>
    </p>

    <table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#a0a0ff">
      <tr valign="top">
        <td width="33%">
          <a href="loading.html">&laquo; previous</a> (loading and importing)
        </td>
        <td width="33%" align="center">
          <a href="index.html">^ up</a> (overview)
        </td>
        <td width="33%" align="right">
          (inference) <a href="inference.html">next &raquo;</a>
        </td>
      </tr>
    </table>
  </body>
</html>
