<p>
Blank nodes with explicit type <code>rdf:List</code>
are treated somewhat differently.
Instead of forming a subgraph we form a smaller graph
by deleting three triples and 
replacing the object of a fourth triple.
</p>
%%lemma('First List Reduction').
<dd>
If <em>g</em> is an acceptable graph
containing a node <em>n</em>
of explicit type <code>rdf:List</code>
such that <em>n</em> is not the object of
a triple with predicate <code>rdf:rest</code>,
and <em>n</em> is the subject of
 a triple with predicate <code>rdf:first</code>
and a uriref 
%%dl_only(Lvl,'or literal').
 object <em>uuu</em>, then it is reducible.
</dd>
<dt>Proof:</dt>
<dd>
By the <a href="triples.html#structural">structural
 constraints</a> on <em>n</em> in <em>g</em> there must be nodes
<em>sss</em>, <em>lll</em> and uriref <em>ppp</em>
such that the following triples are in <em>g</em>.
<pre>
<em>sss ppp n</em> .
<em>n</em> <code>rdf:type rdf:List</code> .
<em>n</em> <code>rdf:first</code> <em>uuu</em> .
<em>n</em> <code>rdf:rest</code> <em>lll</em> .
</pre>
Moreover, there are no other occurrences of <em>n</em>
in <em>g</em>.
Let <em>h</em> be <em>g</em> with these four triples deleted,
 and the following triple added:
<pre>
<em>sss ppp lll</em> .
</pre>
<p>
<em>h</em> is acceptable with the same categorization as
<em>g</em> because:
 <ul>
<li>the node <em>n</em> has been
excised completely, and so cannot contribute to non-acceptability,
</li>
<li>ppp is not rdf:type, (since there is no match in the triple tables)
and so no explicit type triples, other than for <em>n</em>
have been excised.</li>
<li>
<em>lll</em> is either <code>rdf:nil</code> or of
the same category as <em>n</em>, by considering the triple
tables for <code>rdf:rest</code>. Either way
since 
<br />
<em>sss ppp n</em> .
<br />
is in the triple tables, so is
 
<br />
<em>sss ppp lll</em> .

<br />
</li>
<li>Any other contravention of the acceptability of <em>h</em> 
would
not involve the new or deleted triples, and
hence also be a contravention of the acceptability of
<em>g</em>.
</li>
</ul>
Given an abstract syntax tree <em>t</em> corresponding to
<em>h</em> then since the node <em>lll</em>
is either of a list category or <code>rdf:nil</code>,
it must arise from one of the Seq mapping rules.
Moreover ppp is not rdf:rest, and so the context in which
that mapping rule was invoked is not one of the tail recursion
rules <span class="todo">add list of rules</span>.
Thus the mapping rule that gave <em>lll</em> as a result
must have been invoked from <span class="todo">add list of rules</span>.
<br />
In each of these rules, the sequence construct arises from a repeated
construct in an abstract syntax rule one of:
<ul>
<li>{ individualID }</li>
%%dl_only(Lvl,'<li>{ description }</li>').
<li>  { Super( description ) }</li> 
%%dl_only(Lvl,'<li> { dataLiteral }</li>').
</ul>
Modifying <em>t</em> by adding the uriref 
%%dl_only(Lvl,'or literal').
<em>uuu</em>
at the beginning of the appropriate matching subtree 
results in an abstract syntax tree corresponding to <em>g</em>.
</dd>
</dl>


